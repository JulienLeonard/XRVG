    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>bezier.rb - C0 code coverage information</title>
        <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>C0 code coverage information</h3>
        <p>Generated on Mon Sep 01 21:25:49 +0200 2008 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
        </p>
        <hr /><pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='bezier_rb.html'>bezier.rb</a>
          </td>
          <td class='lines_total'>
            <tt>629</tt>
          </td>
          <td class='lines_code'>
            <tt>328</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_total'>99.2%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='99' />
                      <td class='uncovered' width='1' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_code'>98.8%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='99' />
                      <td class='uncovered' width='1' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="inferred1"><a name="line1"></a>  1 # +Bezier+ source
</span><span class="inferred0"><a name="line2"></a>  2 #
</span><span class="inferred1"><a name="line3"></a>  3 
</span><span class="marked0"><a name="line4"></a>  4 require 'bezierspline'
</span><span class="marked1"><a name="line5"></a>  5 require 'shape'
</span><span class="inferred0"><a name="line6"></a>  6 
</span><span class="marked1"><a name="line7"></a>  7 module XRVG
</span><span class="inferred0"><a name="line8"></a>  8 # = Base class for cubic bezier curves
</span><span class="inferred1"><a name="line9"></a>  9 # == Basics
</span><span class="inferred0"><a name="line10"></a> 10 # See http://en.wikipedia.org/wiki/B%C3%A9zier_curve
</span><span class="inferred1"><a name="line11"></a> 11 # == Examples
</span><span class="inferred0"><a name="line12"></a> 12 # Basically, a Bezier curve is a multi-pieces cubic bezier curve. As a first example, you can create bezier curves as follows :
</span><span class="inferred1"><a name="line13"></a> 13 #  b = Bezier[ :pieces, [[:raw, p1, pc1, pc2, p2]] ]; # raw description, as SVG
</span><span class="inferred0"><a name="line14"></a> 14 #  b = Bezier[ :pieces, [[:vector, p1, v1, p2, v2]] ]; # more &quot;symetrical&quot; description.
</span><span class="inferred1"><a name="line15"></a> 15 # For more extensive description, see http://xrvg.rubyforge.org/XRVGBezierCurve.html
</span><span class="inferred0"><a name="line16"></a> 16 # == Discussion
</span><span class="inferred1"><a name="line17"></a> 17 # In XRVG, bezier curves must be also viewed as a way to create smooth and non linear interpolation between values (see +Interpolation+)
</span><span class="inferred0"><a name="line18"></a> 18 #
</span><span class="inferred1"><a name="line19"></a> 19 # Other point : to run along a bezier curve, you can use two different parametrization :
</span><span class="inferred0"><a name="line20"></a> 20 # - the curve generic one, that is &quot;curviligne&quot; abscissa, that is length
</span><span class="inferred1"><a name="line21"></a> 21 # - the bezier parameter, as bezier curves are parametrized curves. For multi-pieces curve, by extension, parameter goes from one integer value to the next one 
</span><span class="inferred0"><a name="line22"></a> 22 # As Bezier class provides several methods with a parameter input, it is necessary to specify with parameter type you want to use ! For example,
</span><span class="inferred1"><a name="line23"></a> 23 # to compute a point from a bezier curve, Bezier class defines the point method as follows :
</span><span class="inferred0"><a name="line24"></a> 24 #   def point( t, parametertype=:length )
</span><span class="inferred1"><a name="line25"></a> 25 # This is a general declaration : every method with a parameter input will propose such a kind of interface :
</span><span class="inferred0"><a name="line26"></a> 26 # - t as Float parameter value
</span><span class="inferred1"><a name="line27"></a> 27 # - parametertype, by default :length, that can have two values, :length or :parameter. :parameter is kept because is far faster than other indexation.
</span><span class="inferred0"><a name="line28"></a> 28 # == Attributes
</span><span class="inferred1"><a name="line29"></a> 29 #  attribute :pieces
</span><span class="marked0"><a name="line30"></a> 30 class Bezier &lt; Curve
</span><span class="marked1"><a name="line31"></a> 31   attribute :pieces
</span><span class="inferred0"><a name="line32"></a> 32 
</span><span class="inferred1"><a name="line33"></a> 33 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line34"></a> 34 #  builders
</span><span class="inferred1"><a name="line35"></a> 35 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line36"></a> 36 
</span><span class="inferred1"><a name="line37"></a> 37   # Initialize with the Attributable format
</span><span class="inferred0"><a name="line38"></a> 38   # 
</span><span class="inferred1"><a name="line39"></a> 39   # 
</span><span class="inferred0"><a name="line40"></a> 40   # Licit formats :
</span><span class="inferred1"><a name="line41"></a> 41   #   b = Bezier.new( :pieces, [BezierSpline[:raw, p1, pc1, pc2, p2]] )
</span><span class="inferred0"><a name="line42"></a> 42   #   b = Bezier[ :pieces, [BezierSpline[:vector, p1, v1, p2, v2]] ]
</span><span class="inferred1"><a name="line43"></a> 43   # However, prefer the use of the following builders
</span><span class="inferred0"><a name="line44"></a> 44   #   b = Bezier.vector( p1, v1, p2, v2 )
</span><span class="inferred1"><a name="line45"></a> 45   #   b = Bezier.raw( p1, pc1, pc2, p2 )
</span><span class="inferred0"><a name="line46"></a> 46   #   b = Bezier.single( :raw, p1, pc1, pc2, p2 )
</span><span class="inferred1"><a name="line47"></a> 47   #   b = Bezier.multi( [[:raw, p1, pc1, pc2, p2], [:raw, p1, pc1, pc2, p2]] )
</span><span class="inferred0"><a name="line48"></a> 48   # The two last syntaxes are provided as shortcuts, as used quite frequently, and must be used instead of :pieces attributable builder
</span><span class="marked1"><a name="line49"></a> 49   def Bezier.[]( *args )
</span><span class="marked0"><a name="line50"></a> 50     self.new( *args )
</span><span class="marked1"><a name="line51"></a> 51   end
</span><span class="inferred0"><a name="line52"></a> 52 
</span><span class="inferred1"><a name="line53"></a> 53   # Uni Bezier builder 
</span><span class="inferred0"><a name="line54"></a> 54   #
</span><span class="inferred1"><a name="line55"></a> 55   # type can be :raw or :vector
</span><span class="marked0"><a name="line56"></a> 56   def Bezier.single( type, p1, p2, p3, p4 )
</span><span class="marked1"><a name="line57"></a> 57     return Bezier.new( :pieces, [BezierSpline[type, p1, p2, p3, p4]] )
</span><span class="marked0"><a name="line58"></a> 58   end
</span><span class="inferred1"><a name="line59"></a> 59 
</span><span class="inferred0"><a name="line60"></a> 60   # Uni Bezier builder in :raw format
</span><span class="marked1"><a name="line61"></a> 61   def Bezier.raw( p1, pc1, pc2, p2 )
</span><span class="marked0"><a name="line62"></a> 62     return Bezier.single( :raw, p1, pc1, pc2, p2 )
</span><span class="marked1"><a name="line63"></a> 63   end
</span><span class="inferred0"><a name="line64"></a> 64 
</span><span class="inferred1"><a name="line65"></a> 65   # Uni Bezier builder in :vector format
</span><span class="marked0"><a name="line66"></a> 66   def Bezier.vector( p1, v1, p2, v2 )
</span><span class="marked1"><a name="line67"></a> 67     return Bezier.single( :vector, p1, v1, p2, v2 )
</span><span class="marked0"><a name="line68"></a> 68   end
</span><span class="inferred1"><a name="line69"></a> 69 
</span><span class="inferred0"><a name="line70"></a> 70   # Uni Bezier builder in :vector format, with vector length normalized at 1/3 dist between points
</span><span class="marked1"><a name="line71"></a> 71   def Bezier.vectorreg( p1, v1, p2, v2 )
</span><span class="marked0"><a name="line72"></a> 72     d = (p1 - p2).r
</span><span class="marked1"><a name="line73"></a> 73     v1 = v1.norm * d/3.0
</span><span class="marked0"><a name="line74"></a> 74     v2 = v2.norm * d/3.0
</span><span class="marked1"><a name="line75"></a> 75     return Bezier.vector( p1, v1, p2, v2 )
</span><span class="inferred0"><a name="line76"></a> 76   end
</span><span class="inferred1"><a name="line77"></a> 77 
</span><span class="inferred0"><a name="line78"></a> 78 
</span><span class="inferred1"><a name="line79"></a> 79   # Basic Multi Bezier builder
</span><span class="inferred0"><a name="line80"></a> 80   #
</span><span class="inferred1"><a name="line81"></a> 81   # raw pieces must be an array of arrays of the form [type, p1, p2, p3, p4] as defined for single
</span><span class="marked0"><a name="line82"></a> 82   def Bezier.multi( rawpieces )
</span><span class="marked1"><a name="line83"></a> 83     return Bezier.new( :pieces, rawpieces.map {|piece| BezierSpline[*piece]} )
</span><span class="marked0"><a name="line84"></a> 84   end
</span><span class="inferred1"><a name="line85"></a> 85 
</span><span class="inferred0"><a name="line86"></a> 86   # &quot;regular&quot; Multi Bezier :raw specification
</span><span class="inferred1"><a name="line87"></a> 87   #
</span><span class="inferred0"><a name="line88"></a> 88   # args is a list of points and control points as [p1, pc1, p2, pc2, p3, pc3]
</span><span class="inferred1"><a name="line89"></a> 89   #
</span><span class="inferred0"><a name="line90"></a> 90   # Beware that 
</span><span class="inferred1"><a name="line91"></a> 91   #  Bezier.raw( p1, pc1, pc2, p2 ) == Bezier.raws( p1, pc1, p2, p2 + (p2-pc2))
</span><span class="marked0"><a name="line92"></a> 92   def Bezier.raws( *args )
</span><span class="marked1"><a name="line93"></a> 93     rawpieces = []
</span><span class="marked0"><a name="line94"></a> 94     args.foreach(2).pairs do |pair1, pair2|
</span><span class="marked1"><a name="line95"></a> 95       p1, pc1 = pair1 
</span><span class="marked0"><a name="line96"></a> 96       p2, pc2 = pair2
</span><span class="marked1"><a name="line97"></a> 97       rawpieces &lt;&lt; [:raw, p1, pc1, p2+(p2-pc2), p2]
</span><span class="inferred0"><a name="line98"></a> 98     end
</span><span class="marked1"><a name="line99"></a> 99     return Bezier.multi( rawpieces )
</span><span class="inferred0"><a name="line100"></a>100   end
</span><span class="inferred1"><a name="line101"></a>101 
</span><span class="inferred0"><a name="line102"></a>102   # &quot;regular&quot; Multi Bezier :vector specification
</span><span class="inferred1"><a name="line103"></a>103   #
</span><span class="inferred0"><a name="line104"></a>104   # args is a list of points and control points as [p1, v1, p2, v2, p3, v3]
</span><span class="inferred1"><a name="line105"></a>105   #
</span><span class="inferred0"><a name="line106"></a>106   # Beware that 
</span><span class="inferred1"><a name="line107"></a>107   #  Bezier.vector( p1, v1, p2, v2 ) == Bezier.vectors( p1, v1, p2, -v2)
</span><span class="marked0"><a name="line108"></a>108   def Bezier.vectors( *args )
</span><span class="marked1"><a name="line109"></a>109     rawpieces = []
</span><span class="marked0"><a name="line110"></a>110     args.foreach(2).pairs do |pair1, pair2|
</span><span class="marked1"><a name="line111"></a>111       p1, v1 = pair1 
</span><span class="marked0"><a name="line112"></a>112       p2, v2 = pair2
</span><span class="marked1"><a name="line113"></a>113       rawpieces &lt;&lt; [:vector, p1, v1, p2, -v2]
</span><span class="inferred0"><a name="line114"></a>114     end
</span><span class="marked1"><a name="line115"></a>115     return Bezier.multi( rawpieces )
</span><span class="inferred0"><a name="line116"></a>116   end
</span><span class="inferred1"><a name="line117"></a>117   
</span><span class="inferred0"><a name="line118"></a>118 
</span><span class="inferred1"><a name="line119"></a>119   
</span><span class="inferred0"><a name="line120"></a>120 
</span><span class="inferred1"><a name="line121"></a>121   # bezier point, as 
</span><span class="inferred0"><a name="line122"></a>122   #   Bezier[:raw, V2D::O, V2D::O, V2D::O, V2D::O]
</span><span class="marked1"><a name="line123"></a>123   O = Bezier.raw( V2D::O, V2D::O, V2D::O, V2D::O )
</span><span class="inferred0"><a name="line124"></a>124 
</span><span class="inferred1"><a name="line125"></a>125 
</span><span class="inferred0"><a name="line126"></a>126   # return piece of index &quot;index&quot;,as BezierSpline object
</span><span class="inferred1"><a name="line127"></a>127   #
</span><span class="inferred0"><a name="line128"></a>128   # index can be 
</span><span class="inferred1"><a name="line129"></a>129   # - integer : in that case, simple return @pieces[index]
</span><span class="inferred0"><a name="line130"></a>130   # - float   : in that case, use second default argument
</span><span class="inferred1"><a name="line131"></a>131   # this method must actually be very rarely called, as usually
</span><span class="inferred0"><a name="line132"></a>132   # we want to compute something with index, and in that case we 
</span><span class="inferred1"><a name="line133"></a>133   # want to delegate computation to a BezierSpline, with parameter
</span><span class="inferred0"><a name="line134"></a>134   # mapping parametermapping
</span><span class="marked1"><a name="line135"></a>135   def piece( index, parametertype=:length )
</span><span class="marked0"><a name="line136"></a>136     pieceindex = index
</span><span class="marked1"><a name="line137"></a>137     if index.is_a? Float
</span><span class="marked0"><a name="line138"></a>138       pieceindex, t = self.parametermapping( index, parametertype )
</span><span class="inferred1"><a name="line139"></a>139     end
</span><span class="marked0"><a name="line140"></a>140     return @pieces[ pieceindex ]
</span><span class="inferred1"><a name="line141"></a>141   end
</span><span class="inferred0"><a name="line142"></a>142 
</span><span class="inferred1"><a name="line143"></a>143   # return number of pieces
</span><span class="marked0"><a name="line144"></a>144   def piecenumber
</span><span class="marked1"><a name="line145"></a>145     return @pieces.length
</span><span class="marked0"><a name="line146"></a>146   end
</span><span class="inferred1"><a name="line147"></a>147 
</span><span class="inferred0"><a name="line148"></a>148 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line149"></a>149 #  curve interface
</span><span class="inferred0"><a name="line150"></a>150 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line151"></a>151 
</span><span class="inferred0"><a name="line152"></a>152   # overload Curve::viewbox
</span><span class="marked1"><a name="line153"></a>153   def viewbox
</span><span class="marked0"><a name="line154"></a>154     return V2D.viewbox( self.pointlist() )
</span><span class="marked1"><a name="line155"></a>155   end
</span><span class="inferred0"><a name="line156"></a>156 
</span><span class="inferred1"><a name="line157"></a>157 
</span><span class="inferred0"><a name="line158"></a>158 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line159"></a>159 #  piece shortcuts
</span><span class="inferred0"><a name="line160"></a>160 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line161"></a>161 
</span><span class="inferred0"><a name="line162"></a>162   # generic method to return points list of a curve
</span><span class="inferred1"><a name="line163"></a>163   #   b = Bezier[ :pieces, [[:raw, p1, pc1, pc2, p2], [:raw, p2, pc2b, pc3, p3]] ]
</span><span class="inferred0"><a name="line164"></a>164   #   b.pointlist        #=&gt; equiv to b.pointlist(:raw) 
</span><span class="inferred1"><a name="line165"></a>165   #   b.pointlist(:raw)  #=&gt; [p1, pc1, pc2, p2, p2, pc2b, pc3, p3]
</span><span class="inferred0"><a name="line166"></a>166   # if you want to get a particular piece pointlist, do
</span><span class="inferred1"><a name="line167"></a>167   #   b.piece( t ).pointlist(nil|:raw|:vector)
</span><span class="inferred0"><a name="line168"></a>168   # TODO : result must be cached by type
</span><span class="marked1"><a name="line169"></a>169   def pointlist( type=:raw )
</span><span class="marked0"><a name="line170"></a>170     result = []
</span><span class="marked1"><a name="line171"></a>171     @pieces.each {|piece| result = result + piece.pointlist(type)}
</span><span class="inferred0"><a name="line172"></a>172     # Trace(&quot;Bezier.pointlist result #{result.inspect}&quot;)
</span><span class="marked1"><a name="line173"></a>173     return result
</span><span class="inferred0"><a name="line174"></a>174   end
</span><span class="inferred1"><a name="line175"></a>175     
</span><span class="inferred0"><a name="line176"></a>176   # shortcut method to get curve first point
</span><span class="marked1"><a name="line177"></a>177   def firstpoint
</span><span class="marked0"><a name="line178"></a>178     return self.pointlist()[0]
</span><span class="marked1"><a name="line179"></a>179   end
</span><span class="inferred0"><a name="line180"></a>180 
</span><span class="inferred1"><a name="line181"></a>181   # shortcut method to get curve last point
</span><span class="marked0"><a name="line182"></a>182   def lastpoint
</span><span class="marked1"><a name="line183"></a>183     return self.pointlist()[-1]
</span><span class="marked0"><a name="line184"></a>184   end
</span><span class="inferred1"><a name="line185"></a>185 
</span><span class="inferred0"><a name="line186"></a>186   # shortcut method to build Bezier objects from each piece
</span><span class="marked1"><a name="line187"></a>187   def beziers
</span><span class="marked0"><a name="line188"></a>188     return self.pieces.map{ |piece| Bezier.single( *piece.data ) }
</span><span class="marked1"><a name="line189"></a>189   end
</span><span class="inferred0"><a name="line190"></a>190 
</span><span class="inferred1"><a name="line191"></a>191   # shortcut method to build Bezier objects from each not regular part
</span><span class="marked0"><a name="line192"></a>192   def sides
</span><span class="marked1"><a name="line193"></a>193     result = []
</span><span class="inferred0"><a name="line194"></a>194     # Trace(&quot;pieces pointlist:&quot;)
</span><span class="inferred1"><a name="line195"></a>195     # self.pieces.each do |piece|
</span><span class="inferred0"><a name="line196"></a>196     #   Trace(&quot;- #{piece.pointlist(:vector).inspect}&quot;)
</span><span class="inferred1"><a name="line197"></a>197     # end
</span><span class="marked0"><a name="line198"></a>198     v0 = self.pieces[0].pointlist(:vector)[1]
</span><span class="marked1"><a name="line199"></a>199     v1 = self.pieces[0].pointlist(:vector)[3]
</span><span class="marked0"><a name="line200"></a>200     subpieces = [self.pieces[0]]
</span><span class="marked1"><a name="line201"></a>201     self.pieces[1..-1].each do |piece|
</span><span class="marked0"><a name="line202"></a>202       fv = piece.pointlist(:vector)[1]
</span><span class="marked1"><a name="line203"></a>203       if not V2D.vequal?( (fv * -1.0).norm, v1.norm, 0.01 )
</span><span class="uncovered0"><a name="line204"></a>204 	# Trace(&quot;fv #{fv.inspect} v1 #{v1.inspect}&quot;)
</span><span class="uncovered1"><a name="line205"></a>205 	result &lt;&lt; subpieces
</span><span class="uncovered0"><a name="line206"></a>206 	subpieces = []
</span><span class="uncovered1"><a name="line207"></a>207       end
</span><span class="marked0"><a name="line208"></a>208       subpieces &lt;&lt; piece
</span><span class="marked1"><a name="line209"></a>209       v1 = piece.pointlist(:vector)[3]
</span><span class="inferred0"><a name="line210"></a>210     end
</span><span class="marked1"><a name="line211"></a>211     if V2D.vequal?( (v0 * -1.0).norm, v1.norm, 0.01 )
</span><span class="inferred0"><a name="line212"></a>212       # Trace(&quot;v0 #{v0.inspect} v1 #{v1.inspect}&quot;)
</span><span class="marked1"><a name="line213"></a>213       if result[0]
</span><span class="uncovered0"><a name="line214"></a>214 	result[0] =  subpieces + result[0]
</span><span class="inferred1"><a name="line215"></a>215       else
</span><span class="marked0"><a name="line216"></a>216 	result = [subpieces]
</span><span class="inferred1"><a name="line217"></a>217       end
</span><span class="marked0"><a name="line218"></a>218       subpieces = []
</span><span class="inferred1"><a name="line219"></a>219     end
</span><span class="inferred0"><a name="line220"></a>220 
</span><span class="marked1"><a name="line221"></a>221     newresult = []
</span><span class="marked0"><a name="line222"></a>222     result.each do |subpieces|
</span><span class="marked1"><a name="line223"></a>223       newresult &lt;&lt; Bezier[ :pieces, subpieces ]
</span><span class="inferred0"><a name="line224"></a>224     end
</span><span class="inferred1"><a name="line225"></a>225     
</span><span class="marked0"><a name="line226"></a>226     return newresult
</span><span class="inferred1"><a name="line227"></a>227   end
</span><span class="inferred0"><a name="line228"></a>228 
</span><span class="inferred1"><a name="line229"></a>229   # shortcut method to retrieve a piece as an Bezier object
</span><span class="marked0"><a name="line230"></a>230   def bezier( index )
</span><span class="marked1"><a name="line231"></a>231     return Bezier.single( *self.piece( index ).data )
</span><span class="marked0"><a name="line232"></a>232   end
</span><span class="inferred1"><a name="line233"></a>233 
</span><span class="inferred0"><a name="line234"></a>234   # shortcut method to retrieve data list of a bezier
</span><span class="marked1"><a name="line235"></a>235   def data
</span><span class="marked0"><a name="line236"></a>236     return self.pieces.map{ |piece| piece.data }
</span><span class="marked1"><a name="line237"></a>237   end
</span><span class="inferred0"><a name="line238"></a>238   
</span><span class="inferred1"><a name="line239"></a>239 
</span><span class="inferred0"><a name="line240"></a>240 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line241"></a>241 #  piece delegation computation
</span><span class="inferred0"><a name="line242"></a>242 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line243"></a>243 
</span><span class="inferred0"><a name="line244"></a>244   # with index (must be Float) and parametertype as inputs, must compute :
</span><span class="inferred1"><a name="line245"></a>245   # - the index of the piece on which the computation must take place
</span><span class="inferred0"><a name="line246"></a>246   # - the new parameter value corresponding to bezier computation input
</span><span class="marked1"><a name="line247"></a>247   def parametermapping( index, parametertype=:length, side=:right ) #:nodoc:
</span><span class="marked0"><a name="line248"></a>248     check_parametertype( parametertype )
</span><span class="marked1"><a name="line249"></a>249     result = []
</span><span class="marked0"><a name="line250"></a>250     if parametertype == :length
</span><span class="marked1"><a name="line251"></a>251       index = (0.0..1.0).trim( index )
</span><span class="marked0"><a name="line252"></a>252       result = length_parameter_mapping( index, side )
</span><span class="inferred1"><a name="line253"></a>253     else # no need to test parametertype value, as check_parametertype already do it
</span><span class="marked0"><a name="line254"></a>254       index = (0.0..self.piecenumber.to_f).trim( index )
</span><span class="marked1"><a name="line255"></a>255       pieceindex = index &lt; self.piecenumber ? index.to_i : (index-1).to_i
</span><span class="marked0"><a name="line256"></a>256       t          = index - pieceindex
</span><span class="marked1"><a name="line257"></a>257       result = [pieceindex, t]
</span><span class="inferred0"><a name="line258"></a>258     end
</span><span class="inferred1"><a name="line259"></a>259 
</span><span class="marked0"><a name="line260"></a>260     return result
</span><span class="inferred1"><a name="line261"></a>261   end
</span><span class="inferred0"><a name="line262"></a>262 
</span><span class="inferred1"><a name="line263"></a>263   # utilitary method to factorize abscissa parameter type value checking
</span><span class="marked0"><a name="line264"></a>264   def check_parametertype( parametertype ) #:nodoc:
</span><span class="marked1"><a name="line265"></a>265     if !(parametertype == :parameter or parametertype == :length )
</span><span class="marked0"><a name="line266"></a>266       Kernel::raise(&quot;Invalid parametertype value #{parametertype}&quot;)
</span><span class="inferred1"><a name="line267"></a>267     end
</span><span class="marked0"><a name="line268"></a>268   end
</span><span class="inferred1"><a name="line269"></a>269 
</span><span class="inferred0"><a name="line270"></a>270 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line271"></a>271 #  bezier computations
</span><span class="inferred0"><a name="line272"></a>272 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line273"></a>273 
</span><span class="inferred0"><a name="line274"></a>274   # compute a point at curviligne abscissa or parameter t 
</span><span class="inferred1"><a name="line275"></a>275   #
</span><span class="inferred0"><a name="line276"></a>276   # curve method redefinition
</span><span class="marked1"><a name="line277"></a>277   def point( t, container=nil, parametertype=:length )
</span><span class="marked0"><a name="line278"></a>278     pieceindex, t = parametermapping( t, parametertype )
</span><span class="marked1"><a name="line279"></a>279     return self.piece( pieceindex ).point( t, container )
</span><span class="inferred0"><a name="line280"></a>280   end
</span><span class="inferred1"><a name="line281"></a>281   
</span><span class="inferred0"><a name="line282"></a>282   # compute tangent at curviligne abscissa or parameter t 
</span><span class="inferred1"><a name="line283"></a>283   #
</span><span class="inferred0"><a name="line284"></a>284   # curve method redefinition
</span><span class="marked1"><a name="line285"></a>285   def tangent ( t, container=nil, parametertype=:length )
</span><span class="marked0"><a name="line286"></a>286     pieceindex, t = parametermapping( t, parametertype )
</span><span class="marked1"><a name="line287"></a>287     return self.piece( pieceindex ).tangent( t, container )
</span><span class="inferred0"><a name="line288"></a>288   end
</span><span class="inferred1"><a name="line289"></a>289 
</span><span class="inferred0"><a name="line290"></a>290   # compute acceleration at curviligne abscissa or parameter t 
</span><span class="inferred1"><a name="line291"></a>291   #
</span><span class="inferred0"><a name="line292"></a>292   # curve method redefinition
</span><span class="marked1"><a name="line293"></a>293   def acc( t, container=nil, parametertype=:length )
</span><span class="marked0"><a name="line294"></a>294     pieceindex, t = parametermapping( t, parametertype )
</span><span class="marked1"><a name="line295"></a>295     return self.piece( pieceindex ).acc( t, container )
</span><span class="inferred0"><a name="line296"></a>296   end
</span><span class="inferred1"><a name="line297"></a>297 
</span><span class="inferred0"><a name="line298"></a>298   # curve method redefinition to factorize parametermapping
</span><span class="marked1"><a name="line299"></a>299   def frame( t, container=nil, parametertype=:length )
</span><span class="marked0"><a name="line300"></a>300     pieceindex, t = parametermapping( t, parametertype )
</span><span class="marked1"><a name="line301"></a>301     containerpoint   = container ? container.center : nil
</span><span class="marked0"><a name="line302"></a>302     containertangent = container ? container.vector : nil
</span><span class="marked1"><a name="line303"></a>303     point    = self.piece( pieceindex ).point( t, containerpoint )
</span><span class="marked0"><a name="line304"></a>304     tangent  = self.piece( pieceindex ).tangent( t, containertangent )
</span><span class="marked1"><a name="line305"></a>305     rotation = self.rotation( nil, tangent )
</span><span class="marked0"><a name="line306"></a>306     scale    = self.scale( nil, tangent )
</span><span class="marked1"><a name="line307"></a>307     result = container ? container : Frame[ :center, point, :vector, tangent, :rotation, rotation, :scale, scale ]
</span><span class="marked0"><a name="line308"></a>308     return result
</span><span class="inferred1"><a name="line309"></a>309   end
</span><span class="inferred0"><a name="line310"></a>310 
</span><span class="inferred1"><a name="line311"></a>311 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line312"></a>312 #  subpiece computation
</span><span class="inferred1"><a name="line313"></a>313 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line314"></a>314 
</span><span class="inferred1"><a name="line315"></a>315   # generalize Bezier method
</span><span class="marked0"><a name="line316"></a>316   def subpieces (t1, t2) #:nodoc:
</span><span class="inferred1"><a name="line317"></a>317     # Trace(&quot;subpieces t1 #{t1} t2 #{t2}&quot;)
</span><span class="marked0"><a name="line318"></a>318     pieceindex1, t1 = parametermapping( t1, :length, :left )
</span><span class="marked1"><a name="line319"></a>319     pieceindex2, t2 = parametermapping( t2, :length, :right )
</span><span class="inferred0"><a name="line320"></a>320     # Trace(&quot;after translation pieceindex1 #{pieceindex1} t1 #{t1}  pieceindex2 #{pieceindex2} t2 #{t2}&quot;)
</span><span class="marked1"><a name="line321"></a>321     result = []
</span><span class="inferred0"><a name="line322"></a>322 
</span><span class="marked1"><a name="line323"></a>323     if pieceindex1 == pieceindex2
</span><span class="marked0"><a name="line324"></a>324       result = [self.piece( pieceindex1 ).subpiece( t1, t2 )]
</span><span class="inferred1"><a name="line325"></a>325     else
</span><span class="marked0"><a name="line326"></a>326       result &lt;&lt; self.piece( pieceindex1 ).subpiece( t1, 1.0 )
</span><span class="marked1"><a name="line327"></a>327       if pieceindex1 + 1 != pieceindex2
</span><span class="marked0"><a name="line328"></a>328 	result += self.pieces[pieceindex1+1..pieceindex2-1]
</span><span class="inferred1"><a name="line329"></a>329       end
</span><span class="marked0"><a name="line330"></a>330       result &lt;&lt; self.piece( pieceindex2 ).subpiece( 0.0, t2 )
</span><span class="inferred1"><a name="line331"></a>331     end
</span><span class="marked0"><a name="line332"></a>332     return result
</span><span class="inferred1"><a name="line333"></a>333   end
</span><span class="inferred0"><a name="line334"></a>334 
</span><span class="inferred1"><a name="line335"></a>335   # compute the sub curve between abscissa t1 and t2
</span><span class="inferred0"><a name="line336"></a>336   #
</span><span class="inferred1"><a name="line337"></a>337   # may result in a multi-pieces Bezier
</span><span class="inferred0"><a name="line338"></a>338   #
</span><span class="inferred1"><a name="line339"></a>339   # Note: special modulo effect to deal with closed bezier curve
</span><span class="inferred0"><a name="line340"></a>340   #
</span><span class="inferred1"><a name="line341"></a>341   # TODO: improve code (bas design)
</span><span class="marked0"><a name="line342"></a>342   def subbezier( t1, t2)
</span><span class="inferred1"><a name="line343"></a>343     # return Bezier.new( :pieces, self.subpieces( t1, t2 ) )
</span><span class="marked0"><a name="line344"></a>344     ranges = (0.0..1.0).modulos( (t1..t2) )
</span><span class="inferred1"><a name="line345"></a>345     # Trace(&quot;Bezier::subbezier t1 #{t1} t2 #{t2} ranges #{ranges.inspect}&quot;)
</span><span class="marked0"><a name="line346"></a>346     pieces = []
</span><span class="marked1"><a name="line347"></a>347     ranges.each do |range|
</span><span class="marked0"><a name="line348"></a>348       range = range.sort
</span><span class="marked1"><a name="line349"></a>349       pieces += self.subpieces( range.begin, range.end )
</span><span class="inferred0"><a name="line350"></a>350     end
</span><span class="inferred1"><a name="line351"></a>351 
</span><span class="marked0"><a name="line352"></a>352     bezier = Bezier.new( :pieces, pieces )
</span><span class="marked1"><a name="line353"></a>353     if t1 &gt; t2
</span><span class="marked0"><a name="line354"></a>354       bezier = bezier.reverse
</span><span class="inferred1"><a name="line355"></a>355     end
</span><span class="marked0"><a name="line356"></a>356     return bezier
</span><span class="inferred1"><a name="line357"></a>357   end
</span><span class="inferred0"><a name="line358"></a>358 
</span><span class="inferred1"><a name="line359"></a>359 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line360"></a>360 #  reverse
</span><span class="inferred1"><a name="line361"></a>361 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line362"></a>362 
</span><span class="inferred1"><a name="line363"></a>363   # return a new Bezier curve reversed from current one
</span><span class="inferred0"><a name="line364"></a>364   #
</span><span class="inferred1"><a name="line365"></a>365   # simply reverse BezierSpline pieces, both internally and in the :pieces list
</span><span class="marked0"><a name="line366"></a>366   def reverse
</span><span class="marked1"><a name="line367"></a>367     newpieces = @pieces.map {|piece| piece.reverse()}
</span><span class="marked0"><a name="line368"></a>368     return Bezier.new( :pieces, newpieces.reverse )
</span><span class="inferred1"><a name="line369"></a>369   end
</span><span class="inferred0"><a name="line370"></a>370 
</span><span class="inferred1"><a name="line371"></a>371 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line372"></a>372 #  translation
</span><span class="inferred1"><a name="line373"></a>373 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line374"></a>374 
</span><span class="inferred1"><a name="line375"></a>375   # translate the Bezier curve, by translating its points
</span><span class="marked0"><a name="line376"></a>376   def translate( v )
</span><span class="marked1"><a name="line377"></a>377     return Bezier.new( :pieces, @pieces.map { |piece| piece.translate( v ) } )
</span><span class="marked0"><a name="line378"></a>378   end
</span><span class="inferred1"><a name="line379"></a>379 
</span><span class="inferred0"><a name="line380"></a>380   # rotate the Bezier curve, by rotating its points
</span><span class="marked1"><a name="line381"></a>381   def rotate( angle, center=V2D::O )
</span><span class="marked0"><a name="line382"></a>382     return Bezier.new( :pieces, @pieces.map { |piece| piece.rotate( angle, center ) } )
</span><span class="marked1"><a name="line383"></a>383   end
</span><span class="inferred0"><a name="line384"></a>384   
</span><span class="inferred1"><a name="line385"></a>385   # central symetry
</span><span class="marked0"><a name="line386"></a>386   def sym( center )
</span><span class="marked1"><a name="line387"></a>387     return Bezier.new( :pieces, @pieces.map { |piece| piece.sym( center ) } )
</span><span class="marked0"><a name="line388"></a>388   end
</span><span class="inferred1"><a name="line389"></a>389 
</span><span class="inferred0"><a name="line390"></a>390   # axis symetry
</span><span class="marked1"><a name="line391"></a>391   def axesym( point, v )
</span><span class="marked0"><a name="line392"></a>392     return Bezier.new( :pieces, @pieces.map { |piece| piece.axesym( point, v ) } )
</span><span class="marked1"><a name="line393"></a>393   end
</span><span class="inferred0"><a name="line394"></a>394 
</span><span class="inferred1"><a name="line395"></a>395 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line396"></a>396 #  similar (transform is used for samplation)
</span><span class="inferred1"><a name="line397"></a>397 #    see XRVG#33
</span><span class="inferred0"><a name="line398"></a>398 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line399"></a>399 
</span><span class="inferred0"><a name="line400"></a>400   # &quot;Similitude&quot; geometric transformation
</span><span class="inferred1"><a name="line401"></a>401   #
</span><span class="inferred0"><a name="line402"></a>402   # See http://en.wikipedia.org/wiki/Similitude_%28geometry%29
</span><span class="inferred1"><a name="line403"></a>403   #
</span><span class="inferred0"><a name="line404"></a>404   # Similtude geometric transformation is (firspoint..lastpoint) -&gt; pointrange
</span><span class="inferred1"><a name="line405"></a>405   #
</span><span class="inferred0"><a name="line406"></a>406   # TODO : method must be put in Curve interface
</span><span class="marked1"><a name="line407"></a>407   def similar( pointrange )
</span><span class="marked0"><a name="line408"></a>408     oldRepere = [self.firstpoint,  self.lastpoint - self.firstpoint]
</span><span class="marked1"><a name="line409"></a>409     newRepere = [pointrange.begin, pointrange.end - pointrange.begin]
</span><span class="marked0"><a name="line410"></a>410     rotation    = V2D.angle( newRepere[1], oldRepere[1] )
</span><span class="marked1"><a name="line411"></a>411     if oldRepere[1].r == 0.0
</span><span class="marked0"><a name="line412"></a>412       Kernel::raise(&quot;similar error : bezier is length 0&quot;)
</span><span class="inferred1"><a name="line413"></a>413     end
</span><span class="marked0"><a name="line414"></a>414     scale       = newRepere[1].r / oldRepere[1].r
</span><span class="marked1"><a name="line415"></a>415     newpoints = []
</span><span class="marked0"><a name="line416"></a>416     self.pointlist.each do |oldpoint|
</span><span class="marked1"><a name="line417"></a>417       oldvector = oldpoint - oldRepere[0]
</span><span class="marked0"><a name="line418"></a>418       newvector = oldvector.rotate( rotation ) * scale
</span><span class="marked1"><a name="line419"></a>419       newpoints.push( newRepere[0] + newvector )
</span><span class="inferred0"><a name="line420"></a>420     end
</span><span class="marked1"><a name="line421"></a>421     splines = []
</span><span class="marked0"><a name="line422"></a>422     newpoints.foreach do |p1, p2, p3, p4|
</span><span class="marked1"><a name="line423"></a>423       splines.push( BezierSpline[:raw, p1, p2, p3, p4] )
</span><span class="inferred0"><a name="line424"></a>424     end
</span><span class="marked1"><a name="line425"></a>425     return Bezier[ :pieces, splines ]
</span><span class="inferred0"><a name="line426"></a>426   end    
</span><span class="inferred1"><a name="line427"></a>427 
</span><span class="inferred0"><a name="line428"></a>428 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line429"></a>429 #  concatenation
</span><span class="inferred0"><a name="line430"></a>430 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line431"></a>431 
</span><span class="inferred0"><a name="line432"></a>432   # Bezier curve concatenation
</span><span class="marked1"><a name="line433"></a>433   def +( other )
</span><span class="marked0"><a name="line434"></a>434     return Bezier.new( :pieces, self.pieces + other.pieces )
</span><span class="marked1"><a name="line435"></a>435   end
</span><span class="inferred0"><a name="line436"></a>436 
</span><span class="inferred1"><a name="line437"></a>437 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line438"></a>438 #  svg
</span><span class="inferred1"><a name="line439"></a>439 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line440"></a>440   
</span><span class="inferred1"><a name="line441"></a>441   # return the svg description of the curve
</span><span class="inferred0"><a name="line442"></a>442   #
</span><span class="inferred1"><a name="line443"></a>443   # if firstpoint == lastpoint, curve is considered as closed
</span><span class="marked0"><a name="line444"></a>444   def svg()
</span><span class="inferred1"><a name="line445"></a>445     # Trace(&quot;Bezier::svg #{self.inspect}&quot;)
</span><span class="marked0"><a name="line446"></a>446     path     = &quot;&quot;
</span><span class="marked1"><a name="line447"></a>447     previous = nil
</span><span class="marked0"><a name="line448"></a>448     self.pieces().each do |piece|
</span><span class="marked1"><a name="line449"></a>449       p1, pc1, pc2, p2 = piece.pointlist
</span><span class="inferred0"><a name="line450"></a>450       # Trace(&quot;previous #{previous.inspect} p1 #{p1.inspect}&quot;)
</span><span class="marked1"><a name="line451"></a>451       if previous == nil or not (previous - p1).r &lt;= 0.0000001
</span><span class="inferred0"><a name="line452"></a>452 	# Trace(&quot;svg bezier not equal =&gt; M&quot;)
</span><span class="marked1"><a name="line453"></a>453 	path += &quot;M #{p1.x},#{p1.y}&quot;
</span><span class="inferred0"><a name="line454"></a>454       end
</span><span class="marked1"><a name="line455"></a>455       previous = p2
</span><span class="marked0"><a name="line456"></a>456       path += &quot;C #{pc1.x},#{pc1.y} #{pc2.x},#{pc2.y} #{p2.x},#{p2.y}&quot;
</span><span class="inferred1"><a name="line457"></a>457     end
</span><span class="inferred0"><a name="line458"></a>458 
</span><span class="marked1"><a name="line459"></a>459     if self.firstpoint == self.lastpoint
</span><span class="marked0"><a name="line460"></a>460       path += &quot; z&quot;
</span><span class="inferred1"><a name="line461"></a>461     end
</span><span class="inferred0"><a name="line462"></a>462 
</span><span class="marked1"><a name="line463"></a>463     result = &quot;&lt;path d=\&quot;#{path}\&quot;/&gt;&quot;
</span><span class="marked0"><a name="line464"></a>464     return result
</span><span class="inferred1"><a name="line465"></a>465   end
</span><span class="inferred0"><a name="line466"></a>466 
</span><span class="inferred1"><a name="line467"></a>467 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line468"></a>468 #  gdebug
</span><span class="inferred1"><a name="line469"></a>469 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line470"></a>470 
</span><span class="inferred1"><a name="line471"></a>471   # Display Bezier curve decorated with points and control points 
</span><span class="marked0"><a name="line472"></a>472   def gdebug(render)
</span><span class="marked1"><a name="line473"></a>473     self.pieces.each {|piece| piece.gdebug(render)}
</span><span class="marked0"><a name="line474"></a>474   end
</span><span class="inferred1"><a name="line475"></a>475 
</span><span class="inferred0"><a name="line476"></a>476 
</span><span class="inferred1"><a name="line477"></a>477 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line478"></a>478 #  length computation
</span><span class="inferred1"><a name="line479"></a>479 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line480"></a>480 
</span><span class="inferred1"><a name="line481"></a>481   # return the length of the bezier curve
</span><span class="inferred0"><a name="line482"></a>482   #
</span><span class="inferred1"><a name="line483"></a>483   # simply add pieces lengths
</span><span class="marked0"><a name="line484"></a>484   def length
</span><span class="marked1"><a name="line485"></a>485     if not @length
</span><span class="marked0"><a name="line486"></a>486       @length = compute_length
</span><span class="inferred1"><a name="line487"></a>487     end
</span><span class="marked0"><a name="line488"></a>488     return @length
</span><span class="inferred1"><a name="line489"></a>489   end
</span><span class="inferred0"><a name="line490"></a>490   
</span><span class="inferred1"><a name="line491"></a>491   # Note : lengthranges building should be more functional ...
</span><span class="inferred0"><a name="line492"></a>492   #        must use an interpolator ?
</span><span class="marked1"><a name="line493"></a>493   def compute_length #:nodoc:
</span><span class="marked0"><a name="line494"></a>494     lengths = self.pieces.map {|piece| piece.length}
</span><span class="inferred1"><a name="line495"></a>495     # Trace(&quot;pieces #{self.pieces.inspect} lenghts #{lengths.inspect}&quot;)
</span><span class="marked0"><a name="line496"></a>496     result  = lengths.sum
</span><span class="marked1"><a name="line497"></a>497     if result == 0.0
</span><span class="marked0"><a name="line498"></a>498       lengths = [1.0]
</span><span class="inferred1"><a name="line499"></a>499     else
</span><span class="marked0"><a name="line500"></a>500       psum = 0.0
</span><span class="marked1"><a name="line501"></a>501       lengths = lengths.map {|v| psum += v/result}
</span><span class="inferred0"><a name="line502"></a>502     end
</span><span class="marked1"><a name="line503"></a>503     lmin = 0.0
</span><span class="marked0"><a name="line504"></a>504     @lengthranges = []
</span><span class="marked1"><a name="line505"></a>505     lengths.each do |llength|
</span><span class="inferred0"><a name="line506"></a>506       # Trace(&quot;lmin #{lmin} llength #{llength}&quot;)
</span><span class="marked1"><a name="line507"></a>507       @lengthranges &lt;&lt; (lmin..llength)
</span><span class="marked0"><a name="line508"></a>508       lmin = llength
</span><span class="inferred1"><a name="line509"></a>509     end
</span><span class="marked0"><a name="line510"></a>510     @lengthranges[-1] = @lengthranges[-1].begin..1.0
</span><span class="marked1"><a name="line511"></a>511     return result
</span><span class="inferred0"><a name="line512"></a>512   end
</span><span class="inferred1"><a name="line513"></a>513   
</span><span class="inferred0"><a name="line514"></a>514   # utilitary method for interbezier
</span><span class="inferred1"><a name="line515"></a>515   #
</span><span class="inferred0"><a name="line516"></a>516   # return list of piece lengths relatives to total bezier lengths, and cumulated
</span><span class="inferred1"><a name="line517"></a>517   #  Bezier.new( :pieces, [piece1, piece2] ).piecelengths; =&gt; [0.0, piece1.length / bezier.length, 1.0]
</span><span class="marked0"><a name="line518"></a>518   def piecelengths
</span><span class="marked1"><a name="line519"></a>519     result = self.lengthranges.map {|range| range.begin}
</span><span class="marked0"><a name="line520"></a>520     result &lt;&lt; 1.0
</span><span class="marked1"><a name="line521"></a>521     return result
</span><span class="inferred0"><a name="line522"></a>522   end
</span><span class="inferred1"><a name="line523"></a>523 
</span><span class="inferred0"><a name="line524"></a>524   # private method, to compute lengthranges if not existing
</span><span class="marked1"><a name="line525"></a>525   def lengthranges #:nodoc:
</span><span class="marked0"><a name="line526"></a>526     if not @lengthranges
</span><span class="marked1"><a name="line527"></a>527       compute_length
</span><span class="inferred0"><a name="line528"></a>528     end
</span><span class="marked1"><a name="line529"></a>529     return @lengthranges
</span><span class="inferred0"><a name="line530"></a>530   end
</span><span class="inferred1"><a name="line531"></a>531 
</span><span class="marked0"><a name="line532"></a>532   def length_parameter_mapping( t, side ) #:nodoc:
</span><span class="marked1"><a name="line533"></a>533     pieceindex = -1
</span><span class="inferred0"><a name="line534"></a>534     # Trace(&quot;self.lengthranges #{self.lengthranges.inspect}&quot;)
</span><span class="marked1"><a name="line535"></a>535     self.lengthranges.each_with_index do |lrange,i|
</span><span class="marked0"><a name="line536"></a>536       if lrange.include?( t )
</span><span class="marked1"><a name="line537"></a>537 	pieceindex = i
</span><span class="marked0"><a name="line538"></a>538 	t = lrange.abscissa( t )
</span><span class="marked1"><a name="line539"></a>539 	t = self.piece( i ).parameterfromlength( t )
</span><span class="inferred0"><a name="line540"></a>540 	# Trace(&quot;pieceindex #{pieceindex} t #{t}&quot;)
</span><span class="marked1"><a name="line541"></a>541 	break
</span><span class="inferred0"><a name="line542"></a>542       end
</span><span class="inferred1"><a name="line543"></a>543     end
</span><span class="marked0"><a name="line544"></a>544     if ((side == :left) and  t.fequal?(1.0) and (pieceindex &lt; self.piecenumber - 1))
</span><span class="marked1"><a name="line545"></a>545       pieceindex += 1
</span><span class="marked0"><a name="line546"></a>546       t = 0.0
</span><span class="inferred1"><a name="line547"></a>547     end
</span><span class="marked0"><a name="line548"></a>548     if pieceindex == -1
</span><span class="marked1"><a name="line549"></a>549       Kernel::raise(&quot;length_parameter_mapping error : t #{t} is not in length range #{self.lengthranges.inspect}&quot;)
</span><span class="inferred0"><a name="line550"></a>550     end
</span><span class="marked1"><a name="line551"></a>551     return [pieceindex, t]
</span><span class="inferred0"><a name="line552"></a>552   end
</span><span class="inferred1"><a name="line553"></a>553   
</span><span class="inferred0"><a name="line554"></a>554   
</span><span class="inferred1"><a name="line555"></a>555     # return a list of bezier params [a1,a2, b1, b2 ...] stating intersection points for each curve
</span><span class="inferred0"><a name="line556"></a>556     # Algo:
</span><span class="inferred1"><a name="line557"></a>557     #  - compute segment approximations of 2 curves, by keeping parameter values
</span><span class="inferred0"><a name="line558"></a>558     #  - for the moment, brute algorithm: try to match every segment of one curve with every of the other
</span><span class="inferred1"><a name="line559"></a>559     # - for every match, dychotomie to get precise parameter value
</span><span class="marked0"><a name="line560"></a>560     def Bezier.intersections( c1, c2 )
</span><span class="marked1"><a name="line561"></a>561       samples = Range.O.samples( 100 )
</span><span class="inferred0"><a name="line562"></a>562       
</span><span class="inferred1"><a name="line563"></a>563       # sample curves
</span><span class="marked0"><a name="line564"></a>564       vs = []
</span><span class="marked1"><a name="line565"></a>565       [c1,c2].each do |c|
</span><span class="marked0"><a name="line566"></a>566 	subvs = []
</span><span class="marked1"><a name="line567"></a>567 	samples.each do |t|
</span><span class="marked0"><a name="line568"></a>568 	  subvs &lt;&lt; [t, c.point( t )]
</span><span class="inferred1"><a name="line569"></a>569 	end
</span><span class="marked0"><a name="line570"></a>570 	vs &lt;&lt; subvs
</span><span class="inferred1"><a name="line571"></a>571       end
</span><span class="inferred0"><a name="line572"></a>572 
</span><span class="inferred1"><a name="line573"></a>573       # detect segment intersections and keep corresponding coords
</span><span class="marked0"><a name="line574"></a>574       rawresult = []
</span><span class="marked1"><a name="line575"></a>575       vs[0].pairs do |s01, s02|
</span><span class="marked0"><a name="line576"></a>576 	vs[1].pairs do |s11, s12|
</span><span class="marked1"><a name="line577"></a>577 	  inter = V2DS[s01[1], s02[1]].intersection( V2DS[s11[1], s12[1]] )
</span><span class="marked0"><a name="line578"></a>578 	  if inter
</span><span class="inferred1"><a name="line579"></a>579 	    # compute distances rapport
</span><span class="marked0"><a name="line580"></a>580 	    r0 = (inter - s01[1]).r / (s02[1] - s01[1]).r
</span><span class="marked1"><a name="line581"></a>581 	    r1 = (inter - s11[1]).r / (s12[1] - s11[1]).r
</span><span class="inferred0"><a name="line582"></a>582 	    # Trace(&quot;Bezier.intersections rapports r0 #{r0} r1 #{r1} s0 V2DS #{V2DS[s01[1], s02[1]].inspect} s1 V2DS #{V2DS[s11[1], s12[1]].inspect}&quot;)
</span><span class="marked1"><a name="line583"></a>583 	    rawresult += [s01[0], s02[0], r0, s11[0], s12[0], r1]
</span><span class="inferred0"><a name="line584"></a>584 	  end
</span><span class="inferred1"><a name="line585"></a>585 	end
</span><span class="inferred0"><a name="line586"></a>586       end
</span><span class="inferred1"><a name="line587"></a>587       
</span><span class="inferred0"><a name="line588"></a>588       # Trace(&quot;Bezier.intersections rawresult #{rawresult.inspect}&quot;)
</span><span class="inferred1"><a name="line589"></a>589 
</span><span class="inferred0"><a name="line590"></a>590       # compute accurately coords
</span><span class="inferred1"><a name="line591"></a>591       # for the moment, just return mean
</span><span class="marked0"><a name="line592"></a>592       result = []
</span><span class="marked1"><a name="line593"></a>593       rawresult.foreach do |t1, t2, r12, t3, t4, r34|
</span><span class="marked0"><a name="line594"></a>594 	result += [(t1..t2).sample( r12 ), (t3..t4).sample( r34 )]
</span><span class="inferred1"><a name="line595"></a>595       end
</span><span class="inferred0"><a name="line596"></a>596 
</span><span class="inferred1"><a name="line597"></a>597       # Trace(&quot;Bezier.intersections result #{result.inspect}&quot;)
</span><span class="inferred0"><a name="line598"></a>598       
</span><span class="marked1"><a name="line599"></a>599       return result
</span><span class="inferred0"><a name="line600"></a>600     end
</span><span class="inferred1"><a name="line601"></a>601 
</span><span class="inferred0"><a name="line602"></a>602 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line603"></a>603 #  sampler computation
</span><span class="inferred0"><a name="line604"></a>604 # -------------------------------------------------------------
</span><span class="marked1"><a name="line605"></a>605   include Samplable
</span><span class="marked0"><a name="line606"></a>606   include Splittable
</span><span class="inferred1"><a name="line607"></a>607 
</span><span class="inferred0"><a name="line608"></a>608   # filter, sampler methods
</span><span class="inferred1"><a name="line609"></a>609   #
</span><span class="inferred0"><a name="line610"></a>610   # just a shortcut to define easily specific sampler on bezier curve
</span><span class="inferred1"><a name="line611"></a>611   #
</span><span class="inferred0"><a name="line612"></a>612   # TODO : must be defined on Curve interface !!
</span><span class="marked1"><a name="line613"></a>613   def filter(type=:point, &amp;block)
</span><span class="marked0"><a name="line614"></a>614       return super(type, &amp;block).addfilter( (0.0..1.0) )
</span><span class="inferred1"><a name="line615"></a>615   end
</span><span class="inferred0"><a name="line616"></a>616 
</span><span class="marked1"><a name="line617"></a>617   def apply_split( t1, t2 ) #:nodoc:
</span><span class="marked0"><a name="line618"></a>618     return self.subbezier( t1, t2 )
</span><span class="marked1"><a name="line619"></a>619   end
</span><span class="inferred0"><a name="line620"></a>620 
</span><span class="marked1"><a name="line621"></a>621   alias apply_sample point
</span><span class="inferred0"><a name="line622"></a>622   # alias apply_split  subbezier
</span><span class="marked1"><a name="line623"></a>623   alias sampler      filter
</span><span class="inferred0"><a name="line624"></a>624 
</span><span class="inferred1"><a name="line625"></a>625   # TODO : add generic bezier builder from points : must be adaptative !! (use Fitting)
</span><span class="inferred0"><a name="line626"></a>626 end
</span><span class="inferred1"><a name="line627"></a>627 end
</span><span class="inferred0"><a name="line628"></a>628 
</span><span class="inferred1"><a name="line629"></a>629 
</span></pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.8.1.2.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
