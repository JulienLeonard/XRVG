    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
      <head>
        <title>utils.rb - C0 code coverage information</title>
        <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
        <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
        <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
        <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
      </head>
      <body>
        <h3>C0 code coverage information</h3>
        <p>Generated on Mon Sep 01 21:25:53 +0200 2008 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
        </p>
        <hr /><pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr class='light'>
          <td>
            <a href='utils_rb.html'>utils.rb</a>
          </td>
          <td class='lines_total'>
            <tt>531</tt>
          </td>
          <td class='lines_code'>
            <tt>308</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_total'>100.0%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='100' />
                      <td class='uncovered' width='0' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt class='coverage_code'>100.0%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='100' />
                      <td class='uncovered' width='0' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="inferred0"><a name="line1"></a>  1 # 
</span><span class="inferred1"><a name="line2"></a>  2 # Several Ruby base class extensions
</span><span class="inferred0"><a name="line3"></a>  3 #
</span><span class="inferred1"><a name="line4"></a>  4 # Please also refer to the following link[http://xrvg.rubyforge.org/], and more particularly this[http://xrvg.rubyforge.org/RubyXRVGExtension.html], for
</span><span class="inferred0"><a name="line5"></a>  5 # further details. 
</span><span class="inferred1"><a name="line6"></a>  6 #
</span><span class="inferred0"><a name="line7"></a>  7 # This contains :
</span><span class="inferred1"><a name="line8"></a>  8 # - +Range+ extension
</span><span class="inferred0"><a name="line9"></a>  9 # - +Array+ extension
</span><span class="inferred1"><a name="line10"></a> 10 
</span><span class="marked0"><a name="line11"></a> 11 require 'enumerator'
</span><span class="marked1"><a name="line12"></a> 12 require 'trace'
</span><span class="marked0"><a name="line13"></a> 13 require 'samplation'
</span><span class="inferred1"><a name="line14"></a> 14 
</span><span class="inferred0"><a name="line15"></a> 15 #
</span><span class="inferred1"><a name="line16"></a> 16 # Extend class Range with module Samplable and other utilitary methods
</span><span class="inferred0"><a name="line17"></a> 17 # = Intro
</span><span class="inferred1"><a name="line18"></a> 18 # Range class is used in XRVG as a continuous 1D float interval.
</span><span class="inferred0"><a name="line19"></a> 19 # See this[http://xrvg.rubyforge.org/RubyXRVGExtension.html] for presentation
</span><span class="inferred1"><a name="line20"></a> 20 # = Use
</span><span class="inferred0"><a name="line21"></a> 21 #  (0.0..1.0).rand
</span><span class="inferred1"><a name="line22"></a> 22 #  (0.0..1.0).middle                    # =&gt; 0.5
</span><span class="inferred0"><a name="line23"></a> 23 #  (0.0..2.0).sample(0.3)               # =&gt; 0.6
</span><span class="inferred1"><a name="line24"></a> 24 #  (0.0..1.0).samples( 3 ) {|v| puts v} # =&gt; &quot;0.0&quot; &quot;0.5&quot; &quot;1.0&quot;
</span><span class="inferred0"><a name="line25"></a> 25 #   
</span><span class="marked1"><a name="line26"></a> 26 class Range
</span><span class="inferred0"><a name="line27"></a> 27   
</span><span class="inferred1"><a name="line28"></a> 28   # constant for (0.0..1.0) range
</span><span class="inferred0"><a name="line29"></a> 29   #
</span><span class="inferred1"><a name="line30"></a> 30   # must be used only as const (else use Range.O)
</span><span class="marked0"><a name="line31"></a> 31   O = (0.0..1.0)
</span><span class="inferred1"><a name="line32"></a> 32 
</span><span class="inferred0"><a name="line33"></a> 33   # constant for Angle range
</span><span class="inferred1"><a name="line34"></a> 34   #
</span><span class="inferred0"><a name="line35"></a> 35   # must be used only as const (else use Range.Angle)
</span><span class="marked1"><a name="line36"></a> 36   Angle = (0.0..2.0*Math::PI)
</span><span class="inferred0"><a name="line37"></a> 37   
</span><span class="inferred1"><a name="line38"></a> 38   # return unitary range, that is 
</span><span class="inferred0"><a name="line39"></a> 39   #   (0.0..1.0) 
</span><span class="marked1"><a name="line40"></a> 40   def Range.O
</span><span class="marked0"><a name="line41"></a> 41     return Range::O.clone
</span><span class="marked1"><a name="line42"></a> 42   end
</span><span class="inferred0"><a name="line43"></a> 43 
</span><span class="inferred1"><a name="line44"></a> 44   # return angle range, that is
</span><span class="inferred0"><a name="line45"></a> 45   #   (0.0..2.0*Math::PI)
</span><span class="marked1"><a name="line46"></a> 46   def Range.Angle
</span><span class="marked0"><a name="line47"></a> 47     return Range::Angle.clone
</span><span class="marked1"><a name="line48"></a> 48   end
</span><span class="inferred0"><a name="line49"></a> 49 
</span><span class="inferred1"><a name="line50"></a> 50   # return symetric angle between 0 and of size .. 2*size
</span><span class="inferred0"><a name="line51"></a> 51   #   (-size..size)
</span><span class="marked1"><a name="line52"></a> 52   def Range.sym( size )
</span><span class="marked0"><a name="line53"></a> 53     size = size &gt; 0.0 ? size : -size
</span><span class="marked1"><a name="line54"></a> 54     return (-size..size)
</span><span class="inferred0"><a name="line55"></a> 55   end
</span><span class="inferred1"><a name="line56"></a> 56 
</span><span class="inferred0"><a name="line57"></a> 57   # compute the symetric of value in context of range
</span><span class="inferred1"><a name="line58"></a> 58   #  (0.0..1.0).complement( 0.3 ) =&gt; 0.7
</span><span class="inferred0"><a name="line59"></a> 59   #  (1.0..2.0).complement( 1.3 ) =&gt; 1.7
</span><span class="marked1"><a name="line60"></a> 60   def complement( value )
</span><span class="marked0"><a name="line61"></a> 61     diff = value - self.begin
</span><span class="marked1"><a name="line62"></a> 62     result = (self.end - diff)
</span><span class="marked0"><a name="line63"></a> 63     return result
</span><span class="inferred1"><a name="line64"></a> 64   end
</span><span class="inferred0"><a name="line65"></a> 65 
</span><span class="inferred1"><a name="line66"></a> 66   # utilitary method to force value to be in range
</span><span class="inferred0"><a name="line67"></a> 67   #  (0.0..1.0).trim( 3.0  ) =&gt; 1.0
</span><span class="inferred1"><a name="line68"></a> 68   #  (0.0..1.0).trim( -3.0 ) =&gt; 0.0
</span><span class="marked0"><a name="line69"></a> 69   def trim( value )
</span><span class="marked1"><a name="line70"></a> 70     if value &gt; self.max
</span><span class="marked0"><a name="line71"></a> 71       value = self.max
</span><span class="marked1"><a name="line72"></a> 72     elsif value &lt; self.min
</span><span class="marked0"><a name="line73"></a> 73       value = self.min
</span><span class="inferred1"><a name="line74"></a> 74     end
</span><span class="marked0"><a name="line75"></a> 75     return value
</span><span class="inferred1"><a name="line76"></a> 76   end
</span><span class="inferred0"><a name="line77"></a> 77 
</span><span class="inferred1"><a name="line78"></a> 78   # return modulo of value given interval
</span><span class="inferred0"><a name="line79"></a> 79   #  (-1.0..1.5).modulo( 2.0 ) =&gt; -0.5
</span><span class="inferred1"><a name="line80"></a> 80   #
</span><span class="inferred0"><a name="line81"></a> 81   # TODO: manage special case range size = 0.0
</span><span class="marked1"><a name="line82"></a> 82   def modulo( value )
</span><span class="marked0"><a name="line83"></a> 83     return ((value - self.min)%self.size + self.min)
</span><span class="marked1"><a name="line84"></a> 84   end
</span><span class="inferred0"><a name="line85"></a> 85 
</span><span class="inferred1"><a name="line86"></a> 86   # compute list of &quot;modulo boundaries&quot;
</span><span class="inferred0"><a name="line87"></a> 87   #  (-1.0..1.5).modulos( (-1.2..2.4) ) =&gt; [(1.3..1.5), (-1.0..1.5), (-1.0..0.4)]
</span><span class="marked1"><a name="line88"></a> 88   def modulos( range )
</span><span class="marked0"><a name="line89"></a> 89     t1 = self.modulo( range.min )
</span><span class="marked1"><a name="line90"></a> 90     t2 = self.modulo( range.max )
</span><span class="marked0"><a name="line91"></a> 91     s1 = ((range.min - self.min)/self.size).floor
</span><span class="marked1"><a name="line92"></a> 92     s2 = ((range.max - self.min)/self.size).floor
</span><span class="marked0"><a name="line93"></a> 93     if s1 == s2
</span><span class="marked1"><a name="line94"></a> 94       result = [(t1..t2)]
</span><span class="inferred0"><a name="line95"></a> 95     else
</span><span class="marked1"><a name="line96"></a> 96       result = [(t1..self.max)]
</span><span class="marked0"><a name="line97"></a> 97       (s2-s1-1).times do 
</span><span class="marked1"><a name="line98"></a> 98 	result &lt;&lt; (self.min..self.max)
</span><span class="inferred0"><a name="line99"></a> 99       end
</span><span class="marked1"><a name="line100"></a>100       if t2 - self.min &gt; 0.0
</span><span class="marked0"><a name="line101"></a>101 	result &lt;&lt; (self.min..t2)
</span><span class="inferred1"><a name="line102"></a>102       end
</span><span class="inferred0"><a name="line103"></a>103     end
</span><span class="marked1"><a name="line104"></a>104     if range.begin &gt; range.end
</span><span class="marked0"><a name="line105"></a>105       result = result.reverse.map {|v| v.reverse}
</span><span class="inferred1"><a name="line106"></a>106     end
</span><span class="inferred0"><a name="line107"></a>107     # Trace(&quot;modulos range #{range.inspect} result #{result.inspect}&quot;)
</span><span class="marked1"><a name="line108"></a>108     return result
</span><span class="inferred0"><a name="line109"></a>109   end
</span><span class="inferred1"><a name="line110"></a>110 
</span><span class="inferred0"><a name="line111"></a>111   # return max value of range
</span><span class="marked1"><a name="line112"></a>112   def max
</span><span class="marked0"><a name="line113"></a>113     return (self.begin &gt; self.end) ? self.begin : self.end
</span><span class="marked1"><a name="line114"></a>114   end
</span><span class="inferred0"><a name="line115"></a>115 
</span><span class="inferred1"><a name="line116"></a>116   # return min value of range
</span><span class="marked0"><a name="line117"></a>117   def min
</span><span class="marked1"><a name="line118"></a>118     return (self.begin &lt; self.end) ? self.begin : self.end
</span><span class="marked0"><a name="line119"></a>119   end
</span><span class="inferred1"><a name="line120"></a>120 
</span><span class="inferred0"><a name="line121"></a>121   # return size of the range
</span><span class="marked1"><a name="line122"></a>122   def size
</span><span class="marked0"><a name="line123"></a>123     return (self.max - self.min)
</span><span class="marked1"><a name="line124"></a>124   end
</span><span class="inferred0"><a name="line125"></a>125 
</span><span class="inferred1"><a name="line126"></a>126 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line127"></a>127 #  Samplable interface include and overriding
</span><span class="inferred1"><a name="line128"></a>128 # -------------------------------------------------------------
</span><span class="marked0"><a name="line129"></a>129   include XRVG::Samplable
</span><span class="marked1"><a name="line130"></a>130   include XRVG::Splittable
</span><span class="inferred0"><a name="line131"></a>131 
</span><span class="inferred1"><a name="line132"></a>132   # Range base FloatFunctor overloading to do
</span><span class="inferred0"><a name="line133"></a>133   #   (1.0..2.0).sample( 0.3 ) =&gt; 1.3
</span><span class="inferred1"><a name="line134"></a>134   #   (1.0..2.0).samples( 3 )  =&gt; [1.0, 1.5, 2.0]
</span><span class="marked0"><a name="line135"></a>135   def transform( value )
</span><span class="marked1"><a name="line136"></a>136     return (self.begin + ( self.end - self.begin ) * value)
</span><span class="marked0"><a name="line137"></a>137   end
</span><span class="inferred1"><a name="line138"></a>138 
</span><span class="inferred0"><a name="line139"></a>139   # Very fundamental generator
</span><span class="inferred1"><a name="line140"></a>140   #
</span><span class="inferred0"><a name="line141"></a>141   # Generates a sequence of &quot;nsamples&quot; floats between 0.0 and 1.0 (included)
</span><span class="marked1"><a name="line142"></a>142   def Range.generate( nsamples )
</span><span class="marked0"><a name="line143"></a>143     result = []
</span><span class="marked1"><a name="line144"></a>144     if nsamples == 1
</span><span class="marked0"><a name="line145"></a>145       result = [0.0]
</span><span class="inferred1"><a name="line146"></a>146     else
</span><span class="marked0"><a name="line147"></a>147       (nsamples).times {|i| result.push( i.to_f / (nsamples-1) )}
</span><span class="inferred1"><a name="line148"></a>148     end
</span><span class="marked0"><a name="line149"></a>149     return result
</span><span class="inferred1"><a name="line150"></a>150   end
</span><span class="inferred0"><a name="line151"></a>151   
</span><span class="inferred1"><a name="line152"></a>152   # Simply redirect on Range.generate
</span><span class="marked0"><a name="line153"></a>153   def generate( nsamples ) #:nodoc:
</span><span class="marked1"><a name="line154"></a>154     return Range.generate( nsamples )
</span><span class="marked0"><a name="line155"></a>155   end
</span><span class="inferred1"><a name="line156"></a>156 
</span><span class="inferred0"><a name="line157"></a>157   # apply_sample is good by default
</span><span class="inferred1"><a name="line158"></a>158   # apply_split  is good by default
</span><span class="inferred0"><a name="line159"></a>159 
</span><span class="inferred1"><a name="line160"></a>160   # returns a reversed range 
</span><span class="inferred0"><a name="line161"></a>161   #  (1.0..2.0).reverse =&gt; (2.0..1.0)
</span><span class="marked1"><a name="line162"></a>162   def reverse
</span><span class="marked0"><a name="line163"></a>163     return Range.new( self.end, self.begin )
</span><span class="marked1"><a name="line164"></a>164   end
</span><span class="inferred0"><a name="line165"></a>165   
</span><span class="inferred1"><a name="line166"></a>166   # returns an increasing Range
</span><span class="inferred0"><a name="line167"></a>167   #  (2.0..1.0).sort =&gt; (1.0..2.0)
</span><span class="marked1"><a name="line168"></a>168   def sort
</span><span class="marked0"><a name="line169"></a>169     return (self.begin &gt; self.end ? Range.new( self.end, self.begin ) : Range.new( self.begin, self.end ))
</span><span class="marked1"><a name="line170"></a>170   end
</span><span class="inferred0"><a name="line171"></a>171 
</span><span class="inferred1"><a name="line172"></a>172   # resize range by factor, with fixed point center of the range
</span><span class="inferred0"><a name="line173"></a>173   #  (1.0..2.0).resize( 0.5 ) =&gt; (1.25..1.75) 
</span><span class="marked1"><a name="line174"></a>174   def resize( factor )
</span><span class="marked0"><a name="line175"></a>175     center   =  self.sample( 0.5 )
</span><span class="marked1"><a name="line176"></a>176     halfsize =  self.size / 2.0
</span><span class="marked0"><a name="line177"></a>177     newhalfsize = halfsize * factor
</span><span class="marked1"><a name="line178"></a>178     return (center - newhalfsize .. center + newhalfsize)
</span><span class="inferred0"><a name="line179"></a>179   end
</span><span class="inferred1"><a name="line180"></a>180 
</span><span class="inferred0"><a name="line181"></a>181   # mean value of the range (equiv to sample( 0.5 ))
</span><span class="inferred1"><a name="line182"></a>182   # -&gt; define in Samplable
</span><span class="inferred0"><a name="line183"></a>183   # def mean()
</span><span class="inferred1"><a name="line184"></a>184   #  return self.sample( 0.5 )
</span><span class="inferred0"><a name="line185"></a>185   # end
</span><span class="inferred1"><a name="line186"></a>186   
</span><span class="inferred0"><a name="line187"></a>187   # alias mean as middle, as sample( 0.5 )
</span><span class="inferred1"><a name="line188"></a>188   # -&gt; define in Samplable
</span><span class="inferred0"><a name="line189"></a>189   # alias middle mean
</span><span class="inferred1"><a name="line190"></a>190 
</span><span class="inferred0"><a name="line191"></a>191   # return range with previous begin as new middle
</span><span class="inferred1"><a name="line192"></a>192   #  (1.0..2.0).sym =&gt; (0.0..2.0)
</span><span class="marked0"><a name="line193"></a>193   def sym()
</span><span class="marked1"><a name="line194"></a>194     return (self.begin - (self.end - self.begin ) .. self.end )
</span><span class="marked0"><a name="line195"></a>195   end
</span><span class="inferred1"><a name="line196"></a>196 
</span><span class="inferred0"><a name="line197"></a>197   # return range with previous end as new middle
</span><span class="inferred1"><a name="line198"></a>198   #  (1.0..2.0).symend =&gt; (1.0..3.0)
</span><span class="marked0"><a name="line199"></a>199   def symend()
</span><span class="marked1"><a name="line200"></a>200     return (self.begin .. self.end + (self.end - self.begin ) )
</span><span class="marked0"><a name="line201"></a>201   end
</span><span class="inferred1"><a name="line202"></a>202 
</span><span class="inferred0"><a name="line203"></a>203   # inverse function of .sample
</span><span class="inferred1"><a name="line204"></a>204   #   (1.0..2.0).abscissa( 0.3 ) =&gt; 1.3
</span><span class="marked0"><a name="line205"></a>205   def abscissa( value )
</span><span class="marked1"><a name="line206"></a>206     if self.begin == self.end
</span><span class="marked0"><a name="line207"></a>207       return self.begin
</span><span class="inferred1"><a name="line208"></a>208     else
</span><span class="marked0"><a name="line209"></a>209       return (value - self.begin) / (self.end - self.begin)
</span><span class="inferred1"><a name="line210"></a>210     end
</span><span class="marked0"><a name="line211"></a>211   end
</span><span class="inferred1"><a name="line212"></a>212   
</span><span class="inferred0"><a name="line213"></a>213   # return a new range with boundaries translated of &quot;value&quot;
</span><span class="inferred1"><a name="line214"></a>214   #   (1.0..2.0).translate( -1.0 ) =&gt; (0.0..1.0)
</span><span class="marked0"><a name="line215"></a>215   def translate( value )
</span><span class="marked1"><a name="line216"></a>216     return (self.begin + value..self.end + value)
</span><span class="marked0"><a name="line217"></a>217   end
</span><span class="inferred1"><a name="line218"></a>218 
</span><span class="inferred0"><a name="line219"></a>219 
</span><span class="inferred1"><a name="line220"></a>220 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line221"></a>221 #   old methods to be refactored
</span><span class="inferred1"><a name="line222"></a>222 # -------------------------------------------------------------
</span><span class="inferred0"><a name="line223"></a>223 
</span><span class="inferred1"><a name="line224"></a>224   # deprecated
</span><span class="inferred0"><a name="line225"></a>225   #
</span><span class="inferred1"><a name="line226"></a>226   # ratios sum must be equal to 1.0
</span><span class="marked0"><a name="line227"></a>227   def multisamples( nsamples, ratios )
</span><span class="marked1"><a name="line228"></a>228     ratiosum  = ratios.sum
</span><span class="marked0"><a name="line229"></a>229     samplesum = nsamples.sum
</span><span class="marked1"><a name="line230"></a>230     ratios = ratios.map {|ratio| ratio / ratiosum}
</span><span class="inferred0"><a name="line231"></a>231     
</span><span class="marked1"><a name="line232"></a>232     rratios = ratios
</span><span class="marked0"><a name="line233"></a>233     index = 0
</span><span class="marked1"><a name="line234"></a>234     ratios.each do |ratio|
</span><span class="marked0"><a name="line235"></a>235       rratios[index] = ratio / nsamples[index]
</span><span class="marked1"><a name="line236"></a>236       index += 1
</span><span class="inferred0"><a name="line237"></a>237     end
</span><span class="inferred1"><a name="line238"></a>238     
</span><span class="marked0"><a name="line239"></a>239     sum = 0.0
</span><span class="marked1"><a name="line240"></a>240     samples = [0.0]
</span><span class="marked0"><a name="line241"></a>241     periodindex = 0
</span><span class="marked1"><a name="line242"></a>242     while sum &lt;= 1.0
</span><span class="marked0"><a name="line243"></a>243       sum += rratios[ periodindex ]
</span><span class="marked1"><a name="line244"></a>244       if sum &gt; 1.0
</span><span class="marked0"><a name="line245"></a>245 	break
</span><span class="inferred1"><a name="line246"></a>246       end
</span><span class="marked0"><a name="line247"></a>247       samples += [sum]
</span><span class="marked1"><a name="line248"></a>248       periodindex += 1
</span><span class="marked0"><a name="line249"></a>249       if periodindex &gt;= rratios.length
</span><span class="marked1"><a name="line250"></a>250 	periodindex = 0.0
</span><span class="inferred0"><a name="line251"></a>251       end 
</span><span class="inferred1"><a name="line252"></a>252     end
</span><span class="marked0"><a name="line253"></a>253     return self.samples( samples )
</span><span class="inferred1"><a name="line254"></a>254   end
</span><span class="inferred0"><a name="line255"></a>255 
</span><span class="inferred1"><a name="line256"></a>256   # alias for .random.samples
</span><span class="marked0"><a name="line257"></a>257   def rand(nsamples=1,&amp;block)
</span><span class="marked1"><a name="line258"></a>258     inputs = []
</span><span class="marked0"><a name="line259"></a>259     nsamples.times {|v| inputs.push( Kernel::rand )}
</span><span class="marked1"><a name="line260"></a>260     result = self.process( inputs, :sample, &amp;block )
</span><span class="marked0"><a name="line261"></a>261     return nsamples == 1 ? result[0] : result
</span><span class="inferred1"><a name="line262"></a>262   end
</span><span class="inferred0"><a name="line263"></a>263 
</span><span class="inferred1"><a name="line264"></a>264   # deprecated
</span><span class="inferred0"><a name="line265"></a>265   #
</span><span class="inferred1"><a name="line266"></a>266   # TODO : must add gauss parameters
</span><span class="marked0"><a name="line267"></a>267   def randgauss()
</span><span class="inferred1"><a name="line268"></a>268     begin 
</span><span class="marked0"><a name="line269"></a>269       x1 = 2.0 * Kernel::rand - 1.0
</span><span class="marked1"><a name="line270"></a>270       x2 = 2.0 * Kernel::rand - 1.0
</span><span class="marked0"><a name="line271"></a>271       w  = x1 * x1 + x2 * x2
</span><span class="marked1"><a name="line272"></a>272     end while w &gt;= 1.0
</span><span class="marked0"><a name="line273"></a>273     w = Math.sqrt( ( -2.0 * Math.log( w ) ) / w )
</span><span class="marked1"><a name="line274"></a>274     return 1.0/2.0 * ( 1.0 + x1 * w )
</span><span class="inferred0"><a name="line275"></a>275   end
</span><span class="inferred1"><a name="line276"></a>276   
</span><span class="inferred0"><a name="line277"></a>277 end
</span><span class="inferred1"><a name="line278"></a>278 
</span><span class="inferred0"><a name="line279"></a>279 #
</span><span class="inferred1"><a name="line280"></a>280 # Array extension (see SyncS for enumeration synchronisation)
</span><span class="inferred0"><a name="line281"></a>281 # See this[http://xrvg.rubyforge.org/RubyXRVGExtension.html] for presentation
</span><span class="inferred1"><a name="line282"></a>282 #
</span><span class="marked0"><a name="line283"></a>283 class Array
</span><span class="inferred1"><a name="line284"></a>284 
</span><span class="inferred0"><a name="line285"></a>285   # take only the nieme elements
</span><span class="inferred1"><a name="line286"></a>286   #
</span><span class="inferred0"><a name="line287"></a>287   # Experimental
</span><span class="inferred1"><a name="line288"></a>288   #   [1, 2, 3, 4].sub(2) =&gt; [1, 3]
</span><span class="marked0"><a name="line289"></a>289   def sub(period, &amp;block)
</span><span class="marked1"><a name="line290"></a>290     result = []
</span><span class="marked0"><a name="line291"></a>291     self.foreach(period) do |slice|
</span><span class="marked1"><a name="line292"></a>292       item = slice[0]
</span><span class="marked0"><a name="line293"></a>293       if block
</span><span class="marked1"><a name="line294"></a>294 	yield item
</span><span class="inferred0"><a name="line295"></a>295       else
</span><span class="marked1"><a name="line296"></a>296 	result.push( item )
</span><span class="inferred0"><a name="line297"></a>297       end
</span><span class="inferred1"><a name="line298"></a>298     end
</span><span class="marked0"><a name="line299"></a>299     return result
</span><span class="inferred1"><a name="line300"></a>300   end
</span><span class="inferred0"><a name="line301"></a>301 
</span><span class="inferred1"><a name="line302"></a>302   # return the sum of the elements of the Array
</span><span class="inferred0"><a name="line303"></a>303   # works for array whose content defines the + operator
</span><span class="inferred1"><a name="line304"></a>304   #  [1.0, 2.0].sum                           =&gt; 3.0
</span><span class="inferred0"><a name="line305"></a>305   #  [V2D[-1.0,-1.0], V2D[1.0,1.0]].sum =&gt; V2D[0.0,0.0]
</span><span class="inferred1"><a name="line306"></a>306   #  [curve1, curve2].sum                     =&gt; concatenation of curves
</span><span class="marked0"><a name="line307"></a>307   def sum
</span><span class="marked1"><a name="line308"></a>308     sum = self[0]
</span><span class="marked0"><a name="line309"></a>309     self[1..-1].each {|v| sum += v}
</span><span class="marked1"><a name="line310"></a>310     return sum
</span><span class="inferred0"><a name="line311"></a>311   end
</span><span class="inferred1"><a name="line312"></a>312 
</span><span class="inferred0"><a name="line313"></a>313   # returns the mean of the array content
</span><span class="inferred1"><a name="line314"></a>314   #  [V2D[0.0,0.0], V2D[1.0,1.0]].mean =&gt; V2D[0.5,0.5]
</span><span class="marked0"><a name="line315"></a>315   def mean
</span><span class="marked1"><a name="line316"></a>316     return self.sum / self.size
</span><span class="marked0"><a name="line317"></a>317   end
</span><span class="inferred1"><a name="line318"></a>318 
</span><span class="inferred0"><a name="line319"></a>319   # return a random item from array
</span><span class="marked1"><a name="line320"></a>320   def choice
</span><span class="marked0"><a name="line321"></a>321     return self[Kernel::rand(self.size)]
</span><span class="marked1"><a name="line322"></a>322   end
</span><span class="inferred0"><a name="line323"></a>323 
</span><span class="inferred1"><a name="line324"></a>324   # return an array with same elements as self, but rotated
</span><span class="marked0"><a name="line325"></a>325   def rotate(sens=:right)
</span><span class="marked1"><a name="line326"></a>326     result = []
</span><span class="marked0"><a name="line327"></a>327     if sens == :right
</span><span class="marked1"><a name="line328"></a>328       result = [self[-1]] + self[0..-2]
</span><span class="inferred0"><a name="line329"></a>329     else
</span><span class="marked1"><a name="line330"></a>330       result = self[1..-1] + [self[0]]
</span><span class="inferred0"><a name="line331"></a>331     end
</span><span class="marked1"><a name="line332"></a>332     return result
</span><span class="inferred0"><a name="line333"></a>333   end
</span><span class="inferred1"><a name="line334"></a>334 
</span><span class="inferred0"><a name="line335"></a>335   # generate every rotation for the array, with as first element self
</span><span class="marked1"><a name="line336"></a>336   def rotations(sens=:right)
</span><span class="marked0"><a name="line337"></a>337     result = [self]
</span><span class="marked1"><a name="line338"></a>338     current = self
</span><span class="marked0"><a name="line339"></a>339     (self.size-1).times do 
</span><span class="marked1"><a name="line340"></a>340       result &lt;&lt; current.rotate(sens)
</span><span class="marked0"><a name="line341"></a>341       current = result[-1]
</span><span class="inferred1"><a name="line342"></a>342     end
</span><span class="marked0"><a name="line343"></a>343     return result
</span><span class="inferred1"><a name="line344"></a>344   end
</span><span class="inferred0"><a name="line345"></a>345 
</span><span class="inferred1"><a name="line346"></a>346   # compute range of an array by returning (min..max)
</span><span class="inferred0"><a name="line347"></a>347   #   [1.0, 3.0, 2.0].range =&gt; (1.0..3.0) 
</span><span class="inferred1"><a name="line348"></a>348   # if proc supplied, use it to return range of subvalues
</span><span class="inferred0"><a name="line349"></a>349   #  [V2D::O, V2D::X].range( :x ) =&gt; (0.0..1.0)
</span><span class="marked1"><a name="line350"></a>350   def range( proc=nil )
</span><span class="marked0"><a name="line351"></a>351     if not proc
</span><span class="marked1"><a name="line352"></a>352       return (self.min..self.max)
</span><span class="inferred0"><a name="line353"></a>353     else
</span><span class="marked1"><a name="line354"></a>354       arraytmp = self.map {|item| item.send( proc )}
</span><span class="marked0"><a name="line355"></a>355       return arraytmp.range
</span><span class="inferred1"><a name="line356"></a>356     end
</span><span class="marked0"><a name="line357"></a>357   end
</span><span class="inferred1"><a name="line358"></a>358 
</span><span class="inferred0"><a name="line359"></a>359   # alias for sub(2)
</span><span class="inferred1"><a name="line360"></a>360   #  [1,2,3,4].half =&gt; [1,3]
</span><span class="marked0"><a name="line361"></a>361   def half( &amp;block )
</span><span class="marked1"><a name="line362"></a>362     return sub(2,&amp;block)
</span><span class="inferred0"><a name="line363"></a>363   end
</span><span class="inferred1"><a name="line364"></a>364 
</span><span class="inferred0"><a name="line365"></a>365   # flatten an array of arrays
</span><span class="inferred1"><a name="line366"></a>366   #  [[1,1], [2,2]].flattenonce =&gt; [1,1,2,2]
</span><span class="marked0"><a name="line367"></a>367   def flattenonce
</span><span class="marked1"><a name="line368"></a>368     result = []
</span><span class="marked0"><a name="line369"></a>369     self.each do |subarray|
</span><span class="marked1"><a name="line370"></a>370       result += subarray
</span><span class="inferred0"><a name="line371"></a>371     end
</span><span class="marked1"><a name="line372"></a>372     return result
</span><span class="inferred0"><a name="line373"></a>373   end
</span><span class="inferred1"><a name="line374"></a>374 
</span><span class="inferred0"><a name="line375"></a>375   # same as Enumerator.each_slice with implicit size given by block.arity, or explicit if no blocks
</span><span class="inferred1"><a name="line376"></a>376   # (in that case, return array of array)
</span><span class="inferred0"><a name="line377"></a>377   # same enumeration model as for Tcl foreach command (see Array.zip method for further compatibility)
</span><span class="inferred1"><a name="line378"></a>378   #   [1,2,3,4].foreach {|v1,v2| puts &quot;#{v1} #{v2}&quot;} =&gt; &quot;1 2&quot; &quot;3 4&quot;
</span><span class="marked0"><a name="line379"></a>379   def foreach( arity=nil, &amp;block )
</span><span class="marked1"><a name="line380"></a>380     if not arity
</span><span class="marked0"><a name="line381"></a>381       arity = block.arity
</span><span class="inferred1"><a name="line382"></a>382     end
</span><span class="marked0"><a name="line383"></a>383     if block
</span><span class="marked1"><a name="line384"></a>384       if arity == 1
</span><span class="marked0"><a name="line385"></a>385 	return self.each( &amp;block )
</span><span class="inferred1"><a name="line386"></a>386       else
</span><span class="marked0"><a name="line387"></a>387 	return self.each_slice(arity, &amp;block)
</span><span class="inferred1"><a name="line388"></a>388       end
</span><span class="inferred0"><a name="line389"></a>389     else
</span><span class="marked1"><a name="line390"></a>390       return self.enum_slice(arity).to_a
</span><span class="inferred0"><a name="line391"></a>391     end
</span><span class="inferred1"><a name="line392"></a>392   end
</span><span class="inferred0"><a name="line393"></a>393 
</span><span class="inferred1"><a name="line394"></a>394   # same as Enumerator.each_cons with implicit size given by block.arity, or explicit if no blocks
</span><span class="inferred0"><a name="line395"></a>395   # (in that case, return array of array)
</span><span class="inferred1"><a name="line396"></a>396   #   [1,2,3,4].uplets {|v1,v2| puts &quot;#{v1} #{v2}&quot;} =&gt; &quot;1 2&quot; &quot;2 3&quot; &quot;3 4&quot;
</span><span class="marked0"><a name="line397"></a>397   def uplets(arity=nil, &amp;block )
</span><span class="marked1"><a name="line398"></a>398     if not arity
</span><span class="marked0"><a name="line399"></a>399       arity = block.arity
</span><span class="inferred1"><a name="line400"></a>400     end
</span><span class="marked0"><a name="line401"></a>401     if block
</span><span class="marked1"><a name="line402"></a>402       return self.each_cons(arity, &amp;block)
</span><span class="inferred0"><a name="line403"></a>403     else
</span><span class="marked1"><a name="line404"></a>404       return self.enum_cons(arity).to_a
</span><span class="inferred0"><a name="line405"></a>405     end
</span><span class="inferred1"><a name="line406"></a>406   end
</span><span class="inferred0"><a name="line407"></a>407 
</span><span class="inferred1"><a name="line408"></a>408   # alias for uplets(2, &amp;block)
</span><span class="inferred0"><a name="line409"></a>409   #   [1,2,3,4].pairs {|v| puts &quot;#{v[0]} #{v[1]}&quot;} =&gt; &quot;1 2&quot; &quot;2 3&quot; &quot;3 4&quot;
</span><span class="marked1"><a name="line410"></a>410   def pairs( &amp;block )
</span><span class="marked0"><a name="line411"></a>411     return self.uplets(2, &amp;block)
</span><span class="inferred1"><a name="line412"></a>412   end
</span><span class="inferred0"><a name="line413"></a>413 
</span><span class="inferred1"><a name="line414"></a>414   # alias for uplets(3, &amp;block)
</span><span class="inferred0"><a name="line415"></a>415   #   [1,2,3,4].pairs {|v| puts &quot;#{v[0]} #{v[1]} #{v[2]}&quot;} =&gt; &quot;1 2 3&quot; &quot;2 3 4&quot;
</span><span class="marked1"><a name="line416"></a>416   def triplets( &amp;block )
</span><span class="marked0"><a name="line417"></a>417     return self.uplets(3, &amp;block)
</span><span class="inferred1"><a name="line418"></a>418   end
</span><span class="inferred0"><a name="line419"></a>419 
</span><span class="inferred1"><a name="line420"></a>420   # aarity = array of arity
</span><span class="inferred0"><a name="line421"></a>421   # if nil, default value is Array.new( self.size, 1 )
</span><span class="inferred1"><a name="line422"></a>422   # size of aarity must be inferior or equal to self.size. If inferior, is completed with 1
</span><span class="inferred0"><a name="line423"></a>423   # Rke : with array size 1, is equivalent to foreach
</span><span class="inferred1"><a name="line424"></a>424   #    [ [1,2,3,4], [a,b] ].forzip( [2,1] ) =&gt; [1,2,a,3,4,b]
</span><span class="inferred0"><a name="line425"></a>425   #    [ [1,2,3,4], [a,b] ].forzip          =&gt; [[1,a], [2,b], [3,nil], [4,nil]]
</span><span class="inferred1"><a name="line426"></a>426   #    [ [a,b], [1,2,3,4] ].forzip          =&gt; [[a,1], [b,2], [nil,3], [nil,4]]
</span><span class="marked0"><a name="line427"></a>427   def forzip(aarity=nil, &amp;block)
</span><span class="marked1"><a name="line428"></a>428     if not aarity
</span><span class="marked0"><a name="line429"></a>429       aarity = Array.new( self.size, 1 )
</span><span class="inferred1"><a name="line430"></a>430     end
</span><span class="marked0"><a name="line431"></a>431     if aarity.size &lt; self.size
</span><span class="marked1"><a name="line432"></a>432       aarity = aarity.concat( Array.new( self.size - aarity.size, 1 ) )
</span><span class="inferred0"><a name="line433"></a>433     end
</span><span class="marked1"><a name="line434"></a>434     tozip = Array.new
</span><span class="marked0"><a name="line435"></a>435     self.zip( aarity ) do |subarray, arity|
</span><span class="marked1"><a name="line436"></a>436       tozip.push( subarray.foreach(arity) )
</span><span class="inferred0"><a name="line437"></a>437     end
</span><span class="marked1"><a name="line438"></a>438     result = tozip[0].zip( *tozip[1..-1] )
</span><span class="marked0"><a name="line439"></a>439     result = result.flattenonce.flattenonce
</span><span class="marked1"><a name="line440"></a>440     if block
</span><span class="marked0"><a name="line441"></a>441       return result.foreach( nil, &amp;block )
</span><span class="inferred1"><a name="line442"></a>442     end
</span><span class="marked0"><a name="line443"></a>443     return result
</span><span class="inferred1"><a name="line444"></a>444   end
</span><span class="inferred0"><a name="line445"></a>445 
</span><span class="inferred1"><a name="line446"></a>446   # in same idea as forzip, but with explicit array index
</span><span class="inferred0"><a name="line447"></a>447   # if pattern is nil, is equivalent to [0,1,..., self.size-1]
</span><span class="inferred1"><a name="line448"></a>448   #   [ [1,2,3,4], [a,b] ].forpattern( [0,0,1] ) =&gt; [1,2,a,3,4,b]
</span><span class="inferred0"><a name="line449"></a>449   #   [ [1,2,3,4], [a,b] ].forpattern( [0,1,0] ) =&gt; [1,a,2,3,b,4]
</span><span class="inferred1"><a name="line450"></a>450   # 
</span><span class="inferred0"><a name="line451"></a>451   # Rke : an interesting application is to use this method to filter some item periodically
</span><span class="inferred1"><a name="line452"></a>452   #       for example [[array]].forpattern( [0,0] ) {|i,j| result.push( i )} take only first item on a pair (to be tested)
</span><span class="inferred0"><a name="line453"></a>453   # Rke2 : not so usefull for the moment (since compared with forzip, the only added value is to allow permutations of values between different subarrays)
</span><span class="marked1"><a name="line454"></a>454   def forpattern(pattern, &amp;block)
</span><span class="marked0"><a name="line455"></a>455     cindexes = Array.new( self.size, 0 )
</span><span class="marked1"><a name="line456"></a>456     result = []
</span><span class="marked0"><a name="line457"></a>457     while true
</span><span class="marked1"><a name="line458"></a>458       newitem = []
</span><span class="marked0"><a name="line459"></a>459       pattern.each do |arrayindex|
</span><span class="marked1"><a name="line460"></a>460 	newitem.push( self.[]( arrayindex )[ cindexes[ arrayindex] ] )
</span><span class="marked0"><a name="line461"></a>461 	cindexes[ arrayindex] += 1
</span><span class="inferred1"><a name="line462"></a>462       end
</span><span class="marked0"><a name="line463"></a>463       if newitem.compact.size == 0
</span><span class="marked1"><a name="line464"></a>464 	break
</span><span class="inferred0"><a name="line465"></a>465       end
</span><span class="marked1"><a name="line466"></a>466       result += newitem
</span><span class="inferred0"><a name="line467"></a>467     end
</span><span class="inferred1"><a name="line468"></a>468     # result = result.flatten
</span><span class="marked0"><a name="line469"></a>469     if block
</span><span class="marked1"><a name="line470"></a>470       return result.foreach( nil, &amp;block )
</span><span class="inferred0"><a name="line471"></a>471     end
</span><span class="marked1"><a name="line472"></a>472     return result
</span><span class="inferred0"><a name="line473"></a>473   end
</span><span class="inferred1"><a name="line474"></a>474 
</span><span class="inferred0"><a name="line475"></a>475   # shuffle values in array
</span><span class="marked1"><a name="line476"></a>476   def shuffle
</span><span class="marked0"><a name="line477"></a>477     return self.sort_by{ rand }
</span><span class="marked1"><a name="line478"></a>478   end
</span><span class="inferred0"><a name="line479"></a>479 end
</span><span class="inferred1"><a name="line480"></a>480 
</span><span class="inferred0"><a name="line481"></a>481 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line482"></a>482 #  String class
</span><span class="inferred0"><a name="line483"></a>483 # -------------------------------------------------------------
</span><span class="inferred1"><a name="line484"></a>484 
</span><span class="marked0"><a name="line485"></a>485 class String #:nodoc:
</span><span class="inferred1"><a name="line486"></a>486 
</span><span class="marked0"><a name="line487"></a>487   def subreplace (tokens)
</span><span class="marked1"><a name="line488"></a>488     gsub(/#{tokens.keys.join(&quot;|&quot;)}/) { tokens[$&amp;] }
</span><span class="marked0"><a name="line489"></a>489   end
</span><span class="inferred1"><a name="line490"></a>490 
</span><span class="inferred0"><a name="line491"></a>491 end
</span><span class="inferred1"><a name="line492"></a>492 
</span><span class="inferred0"><a name="line493"></a>493 # Ruby base class Float extension
</span><span class="inferred1"><a name="line494"></a>494 #
</span><span class="inferred0"><a name="line495"></a>495 # Mainly to be able to compare two floats with specific accuracy
</span><span class="marked1"><a name="line496"></a>496 class Float
</span><span class="inferred0"><a name="line497"></a>497   
</span><span class="inferred1"><a name="line498"></a>498   # compare two Float with specific precision
</span><span class="inferred0"><a name="line499"></a>499   #  assert( 0.25.fequal?( 0.26,0.02) )
</span><span class="inferred1"><a name="line500"></a>500   #  assert_equal( false, 0.25.fequal?( 0.26,0.01) )
</span><span class="marked0"><a name="line501"></a>501   def fequal?( other, epsilon=0.0000000001 )
</span><span class="marked1"><a name="line502"></a>502     return ((self - other).abs &lt; epsilon)
</span><span class="marked0"><a name="line503"></a>503   end
</span><span class="inferred1"><a name="line504"></a>504 
</span><span class="inferred0"><a name="line505"></a>505   # sort and remove duplicated elements of a float list with specific precision
</span><span class="inferred1"><a name="line506"></a>506   #    assert_equal( [0.25],      Float.sort_float_list([0.26,0.25], 0.02 ) )
</span><span class="inferred0"><a name="line507"></a>507   #    assert_equal( [0.25,0.26], Float.sort_float_list([0.26,0.25], 0.01 ) )
</span><span class="marked1"><a name="line508"></a>508   def Float.sort_float_list( floatlist, epsilon=0.0000001 )
</span><span class="marked0"><a name="line509"></a>509     floatlist = floatlist.uniq.sort
</span><span class="marked1"><a name="line510"></a>510     result = [floatlist[0]]
</span><span class="marked0"><a name="line511"></a>511     floatlist[1..-1].each do |item|
</span><span class="marked1"><a name="line512"></a>512       if not item.fequal?( result[-1], epsilon)
</span><span class="marked0"><a name="line513"></a>513 	result.push( item )
</span><span class="inferred1"><a name="line514"></a>514       end
</span><span class="inferred0"><a name="line515"></a>515     end
</span><span class="marked1"><a name="line516"></a>516     return result
</span><span class="inferred0"><a name="line517"></a>517   end
</span><span class="inferred1"><a name="line518"></a>518 
</span><span class="inferred0"><a name="line519"></a>519   # check if an Float item is included in a Float list, with specific precision
</span><span class="inferred1"><a name="line520"></a>520   #   assert( Float.floatlist_include?( [1.0,2.0,3.0001,4.0], 3.0, 0.001 ) )
</span><span class="inferred0"><a name="line521"></a>521   #   assert_equal( false, Float.floatlist_include?( [1.0,2.0,3.0001,4.0], 3.0, 0.0001 ) )
</span><span class="marked1"><a name="line522"></a>522   def Float.floatlist_include?( floatlist, float, epsilon=0.0000001 )
</span><span class="marked0"><a name="line523"></a>523     floatlist.each do |item|
</span><span class="marked1"><a name="line524"></a>524       if item.fequal?( float, epsilon )
</span><span class="marked0"><a name="line525"></a>525 	return true
</span><span class="inferred1"><a name="line526"></a>526       end
</span><span class="inferred0"><a name="line527"></a>527     end
</span><span class="marked1"><a name="line528"></a>528     return false
</span><span class="inferred0"><a name="line529"></a>529   end
</span><span class="inferred1"><a name="line530"></a>530 end
</span><span class="inferred0"><a name="line531"></a>531 
</span></pre><hr />    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a> version 0.8.1.2.</p><p>
          <a href='http://validator.w3.org/check/referer'>
            <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
          </a>
          <a href='http://jigsaw.w3.org/css-validator/check/referer'>
            <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
          </a>
        </p>
      </body>
    </html>
