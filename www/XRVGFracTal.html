<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Fractals</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="stylesheets/styles.css" />
  </head>
  <body>
  <h1>Fractals</h1>

<h2>Principle</h2>

<p>
One of the main recipes to create fractals is to replace a basic shape by a set of equivalent subshapes, and reitering this process on these subshapes.
</p>

<h2>Circle</h2>

<p>
As we have seen in one of the first tutorials, we can experiment this definition with circles in a simple way:
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/circleiterate1.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue ]
<span style="color: #4682b4;">Circle</span>[].samples( 6 ) <span style="color: #ee0000;">do</span> |point|
  render.add( <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.333 ], style)
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/circleiterate2.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue ]
<span style="color: #4682b4;">Circle</span>[].samples( 6 ) <span style="color: #ee0000;">do</span> |point|
  <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.3333 ].samples( 6 ) <span style="color: #ee0000;">do</span> |point|
    render.add( <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.1111 ], style )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/circleiterate3.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue ]
<span style="color: #4682b4;">Circle</span>[].samples( 6 ) <span style="color: #ee0000;">do</span> |point|
  <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.3333 ].samples( 6 ) <span style="color: #ee0000;">do</span> |point|
    <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.1111 ].samples( 6 ) <span style="color: #ee0000;">do</span> |point|
      render.add( <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.037 ], style )
    <span style="color: #ee0000;">end</span>
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<p>
We can soon notice that an interesting pattern emerges, which does not rely on shapes used to build it, but more on the
numerical patterns implied in the process.
We also can notice that notation above is not quite extendable, so we are going to refactor the previous code a bit.
</p>

<p>
We can define two methods:
<ul>
<li>one representing the basic transformation to pass from one circle to its subcircles </li>
<li>the other encoding the recursivity of the process </li>
</ul>

</p>

<p>
By doing this, we can also debug the fact that we use same first and last point during circle sampling.
</p>

<p>
Here is the result, with one additional recursion level:
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/circlerecurse1.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">subcircles</span>( circle, nsamples, radiusfactor )
  <span style="color: #ee0000;">return</span> circle.samples( nsamples )[1..-1].map <span style="color: #ee0000;">do</span> |point|
    <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, circle.radius * radiusfactor ]
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">circlerecurse</span>( circles, niter, nsamples, radiusfactor )
  <span style="color: #ee0000;">if</span> niter == 0
    <span style="color: #ee0000;">return</span> circles
  <span style="color: #ee0000;">else</span>
    subcircles = []
    circles.each <span style="color: #ee0000;">do</span> |circle|
      subcircles += subcircles( circle, nsamples, radiusfactor )
    <span style="color: #ee0000;">end</span>
    <span style="color: #ee0000;">return</span> circlerecurse( subcircles, niter-1, nsamples, radiusfactor )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue ]
circlerecurse( [<span style="color: #4682b4;">Circle</span>[]], 4, 6, 1.0/3.0 ).each <span style="color: #ee0000;">do</span> |circle|
  render.add( circle, style )
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<p>
And one more (check for difference between the two codes :-)
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/circlerecurse2.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">subcircles</span>( circle, nsamples, radiusfactor )
  <span style="color: #ee0000;">return</span> circle.samples( nsamples )[1..-1].map <span style="color: #ee0000;">do</span> |point|
    <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, circle.radius * radiusfactor ]
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">circlerecurse</span>( circles, niter, nsamples, radiusfactor )
  <span style="color: #ee0000;">if</span> niter == 0
    <span style="color: #ee0000;">return</span> circles
  <span style="color: #ee0000;">else</span>
    subcircles = []
    circles.each <span style="color: #ee0000;">do</span> |circle|
      subcircles += subcircles( circle, nsamples, radiusfactor )
    <span style="color: #ee0000;">end</span>
    <span style="color: #ee0000;">return</span> circlerecurse( subcircles, niter-1, nsamples, radiusfactor )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue ]
circlerecurse( [<span style="color: #4682b4;">Circle</span>[]], 5, 6, 1.0/3.0 ).each <span style="color: #ee0000;">do</span> |circle|
  render.add( circle, style )
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<p>
In the last example, the figure seems to dilute itself in the image, while pattern still remains. You can touch here the notion of a fractal attractor:
the fractal attractor is the mathematical object you obtain by iterating the previous process an infinite number of times.
While there are more and more points in the set, the surface to be drawn converges to 0.
</p>

<p>
As a final point, let's use the previous example, and draw every level of recursion:
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/circlerecurseall.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">subcircles</span>( circle, nsamples, radiusfactor )
  <span style="color: #ee0000;">return</span> circle.samples( nsamples )[1..-1].map <span style="color: #ee0000;">do</span> |point|
    <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, circle.radius * radiusfactor ]
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">circlerecurse</span>( circles, niter, nsamples, radiusfactor )
  <span style="color: #ee0000;">if</span> niter == 0
    <span style="color: #ee0000;">return</span> circles
  <span style="color: #ee0000;">else</span>
    subcircles = []
    circles.each <span style="color: #ee0000;">do</span> |circle|
      subcircles += subcircles( circle, nsamples, radiusfactor )
    <span style="color: #ee0000;">end</span>
    <span style="color: #ee0000;">return</span> circlerecurse( subcircles, niter-1, nsamples, radiusfactor )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue( 0.2 ) ]
5.times <span style="color: #ee0000;">do</span> |time|
  circlerecurse( [<span style="color: #4682b4;">Circle</span>[]], time, 6, 1.0/3.0 ).each <span style="color: #ee0000;">do</span> |circle|
    render.add( circle, style )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>




<h2>Arc</h2>

<p>
The very same process can now be extended to other geometrical shapes, as arc bezier curves for example.
Hereafter the recursive shape pattern is first described:
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/arciterate1.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:stroke</span>, <span style="color: #4682b4;">Color</span>.blue, <span style="color: #9b30ff;">:strokewidth</span>, 0.01 ]
arc = <span style="color: #4682b4;">ArcBezier</span>[ <span style="color: #9b30ff;">:support</span>, [<span style="color: #4682b4;">V2D</span>::<span style="color: #4682b4;">O</span>, <span style="color: #4682b4;">V2D</span>::<span style="color: #4682b4;">X</span>] ]
samples = [0.1,0.3,0.4,0.6,0.7,0.9]
subarcs = arc.samples( samples ).foreach(2).map <span style="color: #ee0000;">do</span> |points|
  <span style="color: #4682b4;">ArcBezier</span>[ <span style="color: #9b30ff;">:support</span>, points ]
<span style="color: #ee0000;">end</span>
render.add( arc, style )
subarcs.each {|arc| render.add( arc, style ) }
render.end
</pre></td>
        </tr>
      </table>



<p>
We can then use the same refactoring process as above, to get:
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/arcrecurse1.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">subarcs</span>( arc, samples )
  <span style="color: #ee0000;">return</span> arc.samples( samples ).foreach(2).map <span style="color: #ee0000;">do</span> |points|
    <span style="color: #4682b4;">ArcBezier</span>[<span style="color: #9b30ff;">:support</span>, points ]
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">arcrecurse</span>( arcs, niter, samples )
  <span style="color: #ee0000;">if</span> niter == 0
    <span style="color: #ee0000;">return</span> arcs
  <span style="color: #ee0000;">else</span>
    subarcs = []
    arcs.each <span style="color: #ee0000;">do</span> |arc|
      subarcs += subarcs( arc, samples )
    <span style="color: #ee0000;">end</span>
    <span style="color: #ee0000;">return</span> arcrecurse( subarcs, niter-1, samples )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

render = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:stroke</span>, <span style="color: #4682b4;">Color</span>.blue, <span style="color: #9b30ff;">:strokewidth</span>, 0.01 ]
samples = [0.1,0.3,0.4,0.6,0.7,0.9]
roots   = [<span style="color: #4682b4;">ArcBezier</span>[ <span style="color: #9b30ff;">:support</span>, [<span style="color: #4682b4;">V2D</span>::<span style="color: #4682b4;">O</span>, <span style="color: #4682b4;">V2D</span>::<span style="color: #4682b4;">X</span>]]]
arcrecurse( roots, 4, samples ).each <span style="color: #ee0000;">do</span> |arc|
  render.add( arc, style )
<span style="color: #ee0000;">end</span>
render.end

</pre></td>
        </tr>
      </table>



<p>
As for circle, and more interesting, displaying each recursion level with a slightly different color (and raw management of strokewidth) gives:
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/arcrecurse2.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">subarcs</span>( arc, samples )
  <span style="color: #ee0000;">return</span> arc.samples( samples ).foreach(2).map <span style="color: #ee0000;">do</span> |points|
    <span style="color: #4682b4;">ArcBezier</span>[<span style="color: #9b30ff;">:support</span>, points ]
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

<span style="color: #ee0000;">def</span> <span style="color: #cd3333;">arcrecurse</span>( arcs, niter, samples )
  <span style="color: #ee0000;">if</span> niter &lt;= 0
    <span style="color: #ee0000;">return</span> arcs
  <span style="color: #ee0000;">else</span>
    subarcs = []
    arcs.each <span style="color: #ee0000;">do</span> |arc|
      subarcs += subarcs( arc, samples )
    <span style="color: #ee0000;">end</span>
    <span style="color: #ee0000;">return</span> arcrecurse( subarcs, niter-1, samples )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>

render  = <span style="color: #4682b4;">SVGRender</span>[<span style="color: #9b30ff;">:imagesize</span>, <span style="color: #008b00;">"3cm"</span> ]
style   = <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:stroke</span>, <span style="color: #4682b4;">Color</span>.blue, <span style="color: #9b30ff;">:strokewidth</span>, 0.01 ]
samples = [0.1,0.3,0.4,0.6,0.7,0.9]
roots   = [<span style="color: #4682b4;">ArcBezier</span>[ <span style="color: #9b30ff;">:support</span>, [<span style="color: #4682b4;">V2D</span>::<span style="color: #4682b4;">O</span>, <span style="color: #4682b4;">V2D</span>::<span style="color: #4682b4;">X</span>]]]
palette = <span style="color: #4682b4;">Palette</span>[ <span style="color: #9b30ff;">:colorlist</span>, [  0.0, <span style="color: #4682b4;">Color</span>.black,  
                                  1.0, <span style="color: #4682b4;">Color</span>.blue]]
niter   = 6
<span style="color: #4682b4;">SyncS</span>[(0.0..1.0),(0.01..0.001),palette].samples( niter ) <span style="color: #ee0000;">do</span> |time,width,color|
  time = (niter * time).to_i
  style.stroke = color
  style.strokewidth = width
  arcrecurse( roots, time, samples ).each <span style="color: #ee0000;">do</span> |arc|
    render.add( arc, style )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<h2>Further</h2>

<p>
The previous examples are trivial, and can be extended in numerous ways:
<ul>
<li>alternate motifs at each recursion level </li>
<li>several (random-chosen ?) submotifs from one level to the other </li>
<li>unregular (geo, random-constrained) sampling to compute subshapes </li>
<li>... </li>
<li><a href="XRVGGeoVariety.html">geometrical varieties</a> </li>

  </body>
</html>
