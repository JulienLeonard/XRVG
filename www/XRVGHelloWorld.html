<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Hello World</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="stylesheets/styles.css" />
  </head>
  <body>
  <h1>Hello World</h1>

<h2>Prelude</h2>

<p>
As described before, XRVG basically consists in a set of classes to compute and generate shapes in a SVG format. To effectively display the graphical result, you then need another tool which will "raster" the SVG output. 
</p>

<p>
For the moment, <a href="http://www.mozilla-europe.org/fr/products/firefox/">Firefox</a> will be sufficient.
</p>


<h2>Hello Circle</h2>

<p>
As the world is round, let's begin with drawing a circle.
</p>

<h3>Basics</h3>

<p>
Luckily, XRVG provides for this need the Circle class. To produce the corresponding SVG output, you then just need to pass it to a SVGRender object.
</p>

<p>
This gives the following script :
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/helloworldexpanded.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>.new( <span style="color: #9b30ff;">:filename</span>, <span style="color: #008b00;">"helloworldexpanded.svg"</span> )
render.add( <span style="color: #4682b4;">Circle</span>.new )
render.end
</pre></td>
        </tr>
      </table>



<p>
This example shows :
<ul>
<li>that XRVG generates SVG, according to render class name and by type of file output. </li>
<li>that you must add an object to the render so that it may be effectively generated. This is necessary, since shapes can also be used to make computation (as described in next examples below).  </li>
<li>that class builders have named arguments. This behavior corresponds to the XRVG::Attributable module, which extends somehow the wellknown :attr_accessors "macros" </li>
</ul>

</p>

<h3>More</h3>

<p>
XRVG strives to provide default values as much as possible, and additional syntax sugar. As an illustration, the previous code could be rewritten as follows :
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/helloworldcompact.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

<span style="color: #4682b4;">SVGRender</span>.[] <span style="color: #ee0000;">do</span> |render|
  render.add( <span style="color: #4682b4;">Circle</span>[] )
<span style="color: #ee0000;">end</span>
</pre></td>
        </tr>
      </table>



<p>
This example shows :
<ul>
<li>the fact that XRVG tries to define appropriate default values when possible. Thus, SVGRender default output file is the filename script with svg extension. In the same way, Circle builder is called here with default arguments for :center and :radius. </li>
<li>the use of the "Class[]" syntax for building objects, which IMHO is shorter while more meaningful. </li>
</ul>

</p>

<h2>Crown</h2>

<h3>Stonehenge</h3>

<p>
Let's present a (very) little more complex example, to introduce some interesting XRVG features :
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/hellocrown.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>[ <span style="color: #9b30ff;">:filename</span>, <span style="color: #008b00;">"hellocrown.svg"</span> ]
<span style="color: #4682b4;">Circle</span>[].samples( 8 ) <span style="color: #ee0000;">do</span> |point|
  render.add( <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.2 ], <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue ] )
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<p>
Several things have to be noticed from this example:
<ul>
<li>first the use of the Circle object to compute regularly spaced points on a circle. Instead of explicitely computing points coords from trigonometry formula, a default Circle object is created and ''sampled''. As Circle inherits from Curve class, sampling a curve means by default sampling to get points in a regular way. </li>
<li> As a bonus, the sample method iterates on each point, to make sub circles building straighforward. Such pattern is heavily used in XRVG, and represents a strong design principle (see <a href="RubyXRVGExtension.html">extension</a>). </li>
<li>You can also notice the use of a Style parameter, to change the default style chosen previously for Circle class. You can again see the default argument principle in action: each shape must provide its default style, to allow rapid prototyping in a first step. </li>
<li>And one more thing to notice is that there is actually only SEVEN visible sub circles. This is actually a rendering effect: if you check .svg file, eight circles are indeed created, but first and last sub circle are equal, and as color is plain blue, only one is visible. </li>
</ul>

</p>

<h3>Recursion (again)</h3>

<p>
As an appetizer, let's study the following example, which simply recurse the previous pattern on subcircles: fractals are at hand !!
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/hellocrownrecurse.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>[ <span style="color: #9b30ff;">:filename</span>, <span style="color: #008b00;">"hellocrownrecurse.svg"</span> ]
<span style="color: #4682b4;">Circle</span>[].samples( 8 ) <span style="color: #ee0000;">do</span> |point|
  <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.2 ].samples( 8 ) <span style="color: #ee0000;">do</span> |point|
    render.add( <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, 0.05 ], <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue ] )
  <span style="color: #ee0000;">end</span>
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<h2>Iteration</h2>

<p>
To finish this first tutorial, let's introduce parallel enumeration on radius on previous example:
</p>

<table class="xrvgexample" cellpadding="0" cellspacing="0" border="0" width="100%" summary="">
	<tr>
          <td class="xrvgimage"  align="center" nowrap="nowrap"  border="0">
<center>
<p><img src="images/hellocrown2.png" alt=""></p>
</center>

</td>
	  <td class="xrvgscript" align="left"   nowrap="nowrap"  border="0"><pre class="src">
require <span style="color: #008b00;">'xrvg'</span>
include <span style="color: #4682b4;">XRVG</span>

render = <span style="color: #4682b4;">SVGRender</span>[ <span style="color: #9b30ff;">:filename</span>, <span style="color: #008b00;">"hellocrown2.svg"</span> ]
<span style="color: #4682b4;">SyncS</span>[<span style="color: #4682b4;">Circle</span>[], (0.2..0.1)].samples( 10 ) <span style="color: #ee0000;">do</span> |point, radius|
  render.add( <span style="color: #4682b4;">Circle</span>[<span style="color: #9b30ff;">:center</span>, point, <span style="color: #9b30ff;">:radius</span>, radius ], <span style="color: #4682b4;">Style</span>[ <span style="color: #9b30ff;">:fill</span>, <span style="color: #4682b4;">Color</span>.blue( 0.5 ) ] )
<span style="color: #ee0000;">end</span>
render.end
</pre></td>
        </tr>
      </table>



<p>
As a bonus, you can see how specifying opacity on a basic color. 
</p>

<p>
You can also notice the first and last sub circles, sharing the same center, as previously described.

  </body>
</html>
